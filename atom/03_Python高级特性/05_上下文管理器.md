# ä¸Šä¸‹æ–‡ç®¡ç†å™¨

> åŸå­åŒ–çŸ¥è¯†ç‚¹ | Pythoné«˜çº§ç‰¹æ€§ | LangChain æºç å­¦ä¹ å‰ç½®çŸ¥è¯†

---

## 1. ã€30å­—æ ¸å¿ƒã€‘

**ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ˜¯ Python çš„èµ„æºç®¡ç†åè®®ï¼Œé€šè¿‡ with è¯­å¥è‡ªåŠ¨å¤„ç†èµ„æºçš„è·å–å’Œé‡Šæ”¾ï¼Œæ˜¯ LangChain å›è°ƒè¿½è¸ªçš„åŸºç¡€ã€‚**

---

## 2. ã€ç¬¬ä¸€æ€§åŸç†ã€‘

### ä»€ä¹ˆæ˜¯ç¬¬ä¸€æ€§åŸç†ï¼Ÿ

**ç¬¬ä¸€æ€§åŸç†**ï¼šå›åˆ°äº‹ç‰©æœ€åŸºæœ¬çš„çœŸç†ï¼Œä»æºå¤´æ€è€ƒé—®é¢˜

### ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„ç¬¬ä¸€æ€§åŸç† ğŸ¯

#### 1. æœ€åŸºç¡€çš„å®šä¹‰

**ä¸Šä¸‹æ–‡ç®¡ç†å™¨ = è¿›å…¥æ—¶åšå‡†å¤‡ï¼Œé€€å‡ºæ—¶åšæ¸…ç†**

ä»…æ­¤è€Œå·²ï¼æ²¡æœ‰æ›´åŸºç¡€çš„äº†ã€‚

```python
# æœ€æœ¬è´¨çš„æ¨¡å¼
with something as resource:
    # è¿›å…¥æ—¶ï¼šå‡†å¤‡å·¥ä½œï¼ˆæ‰“å¼€æ–‡ä»¶ã€è·å–é”ã€å»ºç«‹è¿æ¥ï¼‰
    use(resource)
    # é€€å‡ºæ—¶ï¼šæ¸…ç†å·¥ä½œï¼ˆå…³é—­æ–‡ä»¶ã€é‡Šæ”¾é”ã€æ–­å¼€è¿æ¥ï¼‰
# ä¸ç®¡æ˜¯å¦å‡ºé”™ï¼Œæ¸…ç†å·¥ä½œéƒ½ä¼šæ‰§è¡Œ
```

#### 2. ä¸ºä»€ä¹ˆéœ€è¦ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Ÿ

**æ ¸å¿ƒé—®é¢˜ï¼šèµ„æºéœ€è¦æˆå¯¹æ“ä½œï¼ˆæ‰“å¼€/å…³é—­ï¼‰ï¼Œæ‰‹åŠ¨ç®¡ç†å®¹æ˜“å¿˜è®°æˆ–å‡ºé”™**

```python
# æ‰‹åŠ¨ç®¡ç†èµ„æºï¼šå®¹æ˜“å¿˜è®°å…³é—­
f = open("file.txt")
content = f.read()
# å¦‚æœè¿™é‡Œå‡ºé”™ï¼Œæ–‡ä»¶æ°¸è¿œä¸ä¼šå…³é—­ï¼
f.close()

# ç¨å¥½ä¸€ç‚¹ï¼štry-finally
f = open("file.txt")
try:
    content = f.read()
finally:
    f.close()  # ä¿è¯å…³é—­

# æœ€ä¼˜é›…ï¼šwith è¯­å¥
with open("file.txt") as f:
    content = f.read()
# è‡ªåŠ¨å…³é—­ï¼Œå³ä½¿å‡ºé”™ä¹Ÿä¼šå…³é—­
```

#### 3. ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„ä¸‰å±‚ä»·å€¼

##### ä»·å€¼1ï¼šèµ„æºè‡ªåŠ¨æ¸…ç†

```python
# æ–‡ä»¶è‡ªåŠ¨å…³é—­
with open("data.txt") as f:
    data = f.read()

# æ•°æ®åº“è¿æ¥è‡ªåŠ¨å…³é—­
with db.connect() as conn:
    conn.execute(sql)

# é”è‡ªåŠ¨é‡Šæ”¾
with threading.Lock():
    # ä¸´ç•ŒåŒºä»£ç 
    pass
```

##### ä»·å€¼2ï¼šå¼‚å¸¸å®‰å…¨

```python
with open("file.txt") as f:
    content = f.read()
    raise Exception("Something went wrong!")
# å³ä½¿å‡ºé”™ï¼Œæ–‡ä»¶ä¹Ÿä¼šè¢«æ­£ç¡®å…³é—­
```

##### ä»·å€¼3ï¼šä»£ç æ›´ç®€æ´

```python
# æ²¡æœ‰ withï¼šç¹ççš„ try-finally
lock = threading.Lock()
lock.acquire()
try:
    # ä¸´ç•ŒåŒº
    pass
finally:
    lock.release()

# æœ‰ withï¼šä¸€è¡Œæå®š
with threading.Lock():
    # ä¸´ç•ŒåŒº
    pass
```

#### 4. ä»ç¬¬ä¸€æ€§åŸç†æ¨å¯¼ LangChain æºç åº”ç”¨

**æ¨ç†é“¾ï¼š**

```
1. LangChain éœ€è¦è¿½è¸ª Chain/Agent çš„æ‰§è¡Œè¿‡ç¨‹
   â†“
2. è¿½è¸ªéœ€è¦"å¼€å§‹"å’Œ"ç»“æŸ"ä¸¤ä¸ªæ—¶é—´ç‚¹
   â†“
3. è¿™æ˜¯å…¸å‹çš„"æˆå¯¹æ“ä½œ"æ¨¡å¼
   â†“
4. ä¸Šä¸‹æ–‡ç®¡ç†å™¨å®Œç¾åŒ¹é…è¿™ç§æ¨¡å¼
   â†“
5. trace_as_chain_group ç­‰ä¸Šä¸‹æ–‡ç®¡ç†å™¨å®ç°è¿½è¸ª
   â†“
6. å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ”¯æŒå¼‚æ­¥è¿½è¸ª
```

#### 5. ä¸€å¥è¯æ€»ç»“ç¬¬ä¸€æ€§åŸç†

**ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ˜¯"è¿›å…¥æ—¶å‡†å¤‡ã€é€€å‡ºæ—¶æ¸…ç†"çš„ç¼–ç¨‹æ¨¡å¼ï¼Œé€šè¿‡ `__enter__` å’Œ `__exit__` åè®®ä¿è¯èµ„æºå®‰å…¨ï¼Œæ˜¯ LangChain å®ç°å›è°ƒè¿½è¸ªã€èµ„æºç®¡ç†çš„åŸºç¡€è®¾æ–½ã€‚**

---

## 3. ã€æ ¸å¿ƒæ¦‚å¿µï¼ˆå…¨é¢è¦†ç›–ï¼‰ã€‘

### æ ¸å¿ƒæ¦‚å¿µ1ï¼šwith è¯­å¥å’Œåè®® ğŸ·ï¸

**with è¯­å¥è°ƒç”¨å¯¹è±¡çš„ `__enter__` å’Œ `__exit__` æ–¹æ³•**

```python
# with è¯­å¥çš„æ‰§è¡Œæµç¨‹
with expression as variable:
    # 1. è°ƒç”¨ expression.__enter__()
    # 2. è¿”å›å€¼èµ‹ç»™ variable
    # 3. æ‰§è¡Œ with ä»£ç å—
    pass
# 4. è°ƒç”¨ expression.__exit__(exc_type, exc_val, exc_tb)
```

**æ‰‹åŠ¨å®ç°ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼š**

```python
class FileManager:
    """ç®€å•çš„æ–‡ä»¶ç®¡ç†å™¨"""

    def __init__(self, filename: str, mode: str = 'r'):
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        """è¿›å…¥ä¸Šä¸‹æ–‡ï¼šæ‰“å¼€æ–‡ä»¶"""
        print(f"Opening {self.filename}")
        self.file = open(self.filename, self.mode)
        return self.file  # è¿”å›å€¼èµ‹ç»™ as åçš„å˜é‡

    def __exit__(self, exc_type, exc_val, exc_tb):
        """é€€å‡ºä¸Šä¸‹æ–‡ï¼šå…³é—­æ–‡ä»¶"""
        print(f"Closing {self.filename}")
        if self.file:
            self.file.close()
        # è¿”å› True è¡¨ç¤ºå¼‚å¸¸å·²å¤„ç†ï¼Œä¸å†å‘ä¸Šä¼ æ’­
        # è¿”å› False æˆ– None è¡¨ç¤ºå¼‚å¸¸ç»§ç»­ä¼ æ’­
        return False

# ä½¿ç”¨
with FileManager("test.txt", "w") as f:
    f.write("Hello, World!")
# è¾“å‡ºï¼šOpening test.txt
#       Closing test.txt
```

**`__exit__` å‚æ•°è¯¦è§£ï¼š**

| å‚æ•° | è¯´æ˜ | æ— å¼‚å¸¸æ—¶ |
|-----|------|---------|
| `exc_type` | å¼‚å¸¸ç±»å‹ | `None` |
| `exc_val` | å¼‚å¸¸å®ä¾‹ | `None` |
| `exc_tb` | è¿½æº¯ä¿¡æ¯ | `None` |

```python
class ExceptionHandler:
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is ValueError:
            print(f"Caught ValueError: {exc_val}")
            return True  # åæ‰å¼‚å¸¸
        return False  # å…¶ä»–å¼‚å¸¸ç»§ç»­ä¼ æ’­

with ExceptionHandler():
    raise ValueError("Test error")
print("Continues after ValueError")  # ä¼šæ‰§è¡Œ
```

**åœ¨ LangChain æºç ä¸­çš„åº”ç”¨ï¼š**

```python
# langchain_core/tracers/context.py ç®€åŒ–ç‰ˆ
class trace_as_chain_group:
    """è¿½è¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨"""

    def __init__(self, group_name: str):
        self.group_name = group_name

    def __enter__(self):
        # å¼€å§‹è¿½è¸ª
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # ç»“æŸè¿½è¸ª
        return False
```

---

### æ ¸å¿ƒæ¦‚å¿µ2ï¼šcontextlib.contextmanager è£…é¥°å™¨ ğŸ“

**ç”¨ yield ç®€åŒ–ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„å®ç°**

```python
from contextlib import contextmanager

@contextmanager
def timer(name: str):
    """è®¡æ—¶ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    import time
    print(f"[{name}] Start")
    start = time.time()
    try:
        yield  # yield å‰æ˜¯ __enter__ï¼Œyield åæ˜¯ __exit__
    finally:
        elapsed = time.time() - start
        print(f"[{name}] End ({elapsed:.2f}s)")

# ä½¿ç”¨
with timer("Operation"):
    import time
    time.sleep(1)
# è¾“å‡ºï¼š[Operation] Start
#       [Operation] End (1.00s)
```

**yield è¿”å›å€¼ï¼š**

```python
from contextlib import contextmanager

@contextmanager
def managed_resource(name: str):
    """å¸¦è¿”å›å€¼çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    print(f"Acquiring {name}")
    resource = {"name": name, "data": []}  # åˆ›å»ºèµ„æº

    try:
        yield resource  # yield çš„å€¼ä¼šèµ‹ç»™ as åçš„å˜é‡
    finally:
        print(f"Releasing {name}")
        resource.clear()

with managed_resource("database") as db:
    db["data"].append("record1")
    print(f"Using: {db}")
```

**å¼‚å¸¸å¤„ç†ï¼š**

```python
from contextlib import contextmanager

@contextmanager
def error_handler():
    """é”™è¯¯å¤„ç†ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
    try:
        yield
    except ValueError as e:
        print(f"Caught ValueError: {e}")
    except Exception as e:
        print(f"Caught Exception: {e}")
        raise  # é‡æ–°æŠ›å‡º

with error_handler():
    raise ValueError("test")  # è¢«æ•è·ï¼Œä¸ä¼šä¼ æ’­
```

**åœ¨ LangChain æºç ä¸­çš„åº”ç”¨ï¼š**

```python
# langchain_core/callbacks/manager.py ç®€åŒ–ç‰ˆ
from contextlib import contextmanager

@contextmanager
def trace_as_chain_group(
    group_name: str,
    callback_manager = None,
):
    """è¿½è¸ªä¸€ç»„æ“ä½œ"""
    # å¼€å§‹è¿½è¸ª
    group = CallbackGroup(group_name)
    try:
        yield group
    finally:
        # ç»“æŸè¿½è¸ª
        group.end()
```

---

### æ ¸å¿ƒæ¦‚å¿µ3ï¼šå¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ ğŸ”§

**async with ç”¨äºå¼‚æ­¥èµ„æºç®¡ç†**

```python
import asyncio

class AsyncConnection:
    """å¼‚æ­¥æ•°æ®åº“è¿æ¥"""

    def __init__(self, host: str):
        self.host = host
        self.connected = False

    async def __aenter__(self):
        """å¼‚æ­¥è¿›å…¥ï¼šå»ºç«‹è¿æ¥"""
        print(f"Connecting to {self.host}...")
        await asyncio.sleep(0.1)  # æ¨¡æ‹Ÿå¼‚æ­¥è¿æ¥
        self.connected = True
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """å¼‚æ­¥é€€å‡ºï¼šæ–­å¼€è¿æ¥"""
        print(f"Disconnecting from {self.host}...")
        await asyncio.sleep(0.1)  # æ¨¡æ‹Ÿå¼‚æ­¥æ–­å¼€
        self.connected = False
        return False

async def main():
    async with AsyncConnection("localhost") as conn:
        print(f"Connected: {conn.connected}")
        await asyncio.sleep(0.5)  # ä½¿ç”¨è¿æ¥

asyncio.run(main())
```

**contextlib.asynccontextmanagerï¼š**

```python
from contextlib import asynccontextmanager
import asyncio

@asynccontextmanager
async def async_timer(name: str):
    """å¼‚æ­¥è®¡æ—¶å™¨"""
    print(f"[{name}] Start")
    start = asyncio.get_event_loop().time()
    try:
        yield
    finally:
        elapsed = asyncio.get_event_loop().time() - start
        print(f"[{name}] End ({elapsed:.2f}s)")

async def main():
    async with async_timer("Async Operation"):
        await asyncio.sleep(1)

asyncio.run(main())
```

**åœ¨ LangChain æºç ä¸­çš„åº”ç”¨ï¼š**

```python
# langchain_core/runnables/base.py ç®€åŒ–ç‰ˆ
from contextlib import asynccontextmanager

class Runnable:
    @asynccontextmanager
    async def _atrace(self, input):
        """å¼‚æ­¥è¿½è¸ªä¸Šä¸‹æ–‡"""
        # å¼€å§‹è¿½è¸ª
        trace_id = start_trace()
        try:
            yield trace_id
        finally:
            # ç»“æŸè¿½è¸ª
            end_trace(trace_id)
```

---

### æ‰©å±•æ¦‚å¿µ4ï¼šcontextlib.ExitStack ğŸ“‹

**ç®¡ç†å¤šä¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨**

```python
from contextlib import ExitStack

# åŒæ—¶ç®¡ç†å¤šä¸ªèµ„æº
with ExitStack() as stack:
    f1 = stack.enter_context(open("file1.txt", "w"))
    f2 = stack.enter_context(open("file2.txt", "w"))
    f3 = stack.enter_context(open("file3.txt", "w"))

    f1.write("content1")
    f2.write("content2")
    f3.write("content3")
# æ‰€æœ‰æ–‡ä»¶éƒ½ä¼šè¢«æ­£ç¡®å…³é—­
```

**åŠ¨æ€æ•°é‡çš„èµ„æºï¼š**

```python
from contextlib import ExitStack

filenames = ["a.txt", "b.txt", "c.txt"]

with ExitStack() as stack:
    files = [
        stack.enter_context(open(name, "w"))
        for name in filenames
    ]
    for i, f in enumerate(files):
        f.write(f"Content {i}")
```

**æ³¨å†Œæ¸…ç†å›è°ƒï¼š**

```python
from contextlib import ExitStack

def cleanup(name):
    print(f"Cleaning up {name}")

with ExitStack() as stack:
    stack.callback(cleanup, "resource1")
    stack.callback(cleanup, "resource2")
    print("Doing work...")
# è¾“å‡ºï¼š
# Doing work...
# Cleaning up resource2  # åæ³¨å†Œå…ˆæ‰§è¡Œï¼ˆLIFOï¼‰
# Cleaning up resource1
```

---

### æ‰©å±•æ¦‚å¿µ5ï¼šcontextlib.suppress ğŸ”‡

**å¿½ç•¥ç‰¹å®šå¼‚å¸¸**

```python
from contextlib import suppress
import os

# ä¼ ç»Ÿæ–¹å¼
try:
    os.remove("maybe_exists.txt")
except FileNotFoundError:
    pass

# ä½¿ç”¨ suppress
with suppress(FileNotFoundError):
    os.remove("maybe_exists.txt")
# å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œé™é»˜å¿½ç•¥
```

**å¿½ç•¥å¤šç§å¼‚å¸¸ï¼š**

```python
from contextlib import suppress

with suppress(FileNotFoundError, PermissionError):
    os.remove("file.txt")
```

---

### æ‰©å±•æ¦‚å¿µ6ï¼šcontextlib.redirect_stdout ğŸ“¤

**é‡å®šå‘æ ‡å‡†è¾“å‡º**

```python
from contextlib import redirect_stdout
import io

# æ•è·æ‰“å°è¾“å‡º
buffer = io.StringIO()
with redirect_stdout(buffer):
    print("This goes to buffer")
    print("So does this")

captured = buffer.getvalue()
print(f"Captured: {captured!r}")
```

**é‡å®šå‘åˆ°æ–‡ä»¶ï¼š**

```python
from contextlib import redirect_stdout

with open("output.txt", "w") as f:
    with redirect_stdout(f):
        print("This goes to file")
```

---

### æ‰©å±•æ¦‚å¿µ7ï¼šcontextlib.nullcontext ğŸš«

**ä¸åšä»»ä½•äº‹çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨**

```python
from contextlib import nullcontext

def process(data, lock=None):
    """å¯é€‰çš„é”"""
    with lock or nullcontext():
        # å¦‚æœ lock æ˜¯ Noneï¼Œä½¿ç”¨ nullcontextï¼ˆä»€ä¹ˆéƒ½ä¸åšï¼‰
        return data.upper()

# å¸¦é”
import threading
lock = threading.Lock()
process("hello", lock)

# ä¸å¸¦é”
process("hello")  # ä¹Ÿå¯ä»¥æ­£å¸¸å·¥ä½œ
```

**æ¡ä»¶ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼š**

```python
from contextlib import nullcontext

def maybe_open(filename=None):
    if filename:
        return open(filename, "w")
    return nullcontext()

with maybe_open("test.txt") as f:
    if f:
        f.write("hello")

with maybe_open() as f:
    # f æ˜¯ Noneï¼Œä½†ä¸ä¼šæŠ¥é”™
    pass
```

---

## 4. ã€æœ€å°å¯ç”¨ã€‘

æŒæ¡ä»¥ä¸‹å†…å®¹ï¼Œå°±èƒ½å¼€å§‹é˜…è¯» LangChain æºç ï¼š

### 4.1 with è¯­å¥åŸºç¡€

```python
# è‡ªåŠ¨èµ„æºç®¡ç†
with open("file.txt") as f:
    content = f.read()
# è‡ªåŠ¨å…³é—­ï¼Œå³ä½¿å‡ºé”™
```

### 4.2 å®ç°ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼ˆç±»æ–¹å¼ï¼‰

```python
class MyContext:
    def __enter__(self):
        # å‡†å¤‡å·¥ä½œ
        return self  # è¿”å›ç»™ as

    def __exit__(self, exc_type, exc_val, exc_tb):
        # æ¸…ç†å·¥ä½œ
        return False  # ä¸åæ‰å¼‚å¸¸
```

### 4.3 å®ç°ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼ˆè£…é¥°å™¨æ–¹å¼ï¼‰

```python
from contextlib import contextmanager

@contextmanager
def my_context():
    # yield å‰ï¼š__enter__
    resource = acquire_resource()
    try:
        yield resource  # è¿”å›ç»™ as
    finally:
        # yield åï¼š__exit__
        release_resource(resource)
```

### 4.4 å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨

```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def async_context():
    await setup()
    try:
        yield
    finally:
        await cleanup()

# ä½¿ç”¨
async with async_context():
    await do_work()
```

### 4.5 ç†è§£ LangChain çš„è¿½è¸ªä¸Šä¸‹æ–‡

```python
# LangChain çš„è¿½è¸ªæ¨¡å¼
with trace_as_chain_group("my_group"):
    # è¿™é‡Œçš„æ“ä½œéƒ½ä¼šè¢«è¿½è¸ª
    chain.invoke(input)
```

**è¿™äº›çŸ¥è¯†è¶³ä»¥ï¼š**
- é˜…è¯» LangChain æºç ä¸­çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨ç”¨æ³•
- ç†è§£å›è°ƒè¿½è¸ªçš„å®ç°åŸç†
- ç¼–å†™è‡ªå·±çš„èµ„æºç®¡ç†å™¨

---

## 5. ã€1ä¸ªç±»æ¯”ã€‘ï¼ˆåŒè½¨åˆ¶ï¼‰

### ç±»æ¯”1ï¼šwith è¯­å¥

#### ğŸ¨ å‰ç«¯è§†è§’ï¼štry-finally / useEffect cleanup

Python çš„ with è¯­å¥ç±»ä¼¼äº JavaScript çš„ try-finally æˆ– React çš„ useEffect cleanupã€‚

```javascript
// JavaScript: try-finally æ‰‹åŠ¨ç®¡ç†
const resource = acquire();
try {
  use(resource);
} finally {
  release(resource);
}

// React: useEffect è‡ªåŠ¨æ¸…ç†
useEffect(() => {
  const subscription = subscribe();
  return () => {
    // cleanup function
    subscription.unsubscribe();
  };
}, []);
```

```python
# Python: with è‡ªåŠ¨ç®¡ç†
with acquire() as resource:
    use(resource)
# è‡ªåŠ¨è°ƒç”¨ release
```

**å¯¹åº”å…³ç³»ï¼š**

| JavaScript/React | Python with |
|-----------------|-------------|
| `try { } finally { }` | `with ... as ...:` |
| `useEffect return` | `__exit__` |
| `componentWillUnmount` | `__exit__` |

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šè¿›æˆ¿é—´å¼€ç¯ï¼Œå‡ºå»å…³ç¯

with è¯­å¥å°±åƒè¿›æˆ¿é—´çš„è§„çŸ©ï¼š

- **è¿›æˆ¿é—´**ï¼ˆ`__enter__`ï¼‰ï¼šå¼€ç¯
- **åœ¨æˆ¿é—´é‡Œ**ï¼šåšäº‹æƒ…
- **å‡ºæˆ¿é—´**ï¼ˆ`__exit__`ï¼‰ï¼šå…³ç¯

ä¸ç®¡ä½ åœ¨æˆ¿é—´é‡Œåšä»€ä¹ˆï¼ˆå³ä½¿æ‰“ç¿»äº†ä¸œè¥¿ï¼‰ï¼Œå‡ºå»çš„æ—¶å€™ç¯éƒ½è¦å…³æ‰ï¼

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
with è¿›æ•™å®¤:
    ä¸Šè¯¾
    åšç¬”è®°
    (å³ä½¿ä¸‹è¯¾é“ƒå“äº†)
# ä¸€å®šè¦æ“¦é»‘æ¿ã€å…³çª—ã€é”é—¨

è¿™å°±æ˜¯"æœ‰å§‹æœ‰ç»ˆ"ï¼
```

---

### ç±»æ¯”2ï¼š__enter__ å’Œ __exit__

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šç”Ÿå‘½å‘¨æœŸé’©å­

```javascript
// React ç±»ç»„ä»¶ç”Ÿå‘½å‘¨æœŸ
class MyComponent extends React.Component {
  componentDidMount() {
    // ç±»ä¼¼ __enter__
    this.subscription = subscribe();
  }

  componentWillUnmount() {
    // ç±»ä¼¼ __exit__
    this.subscription.unsubscribe();
  }
}
```

```python
# Python ä¸Šä¸‹æ–‡ç®¡ç†å™¨
class MyContext:
    def __enter__(self):
        # ç±»ä¼¼ componentDidMount
        self.subscription = subscribe()
        return self

    def __exit__(self, *args):
        # ç±»ä¼¼ componentWillUnmount
        self.subscription.unsubscribe()
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šä¸Šå­¦å’Œæ”¾å­¦

`__enter__` å’Œ `__exit__` å°±åƒä¸Šå­¦å’Œæ”¾å­¦ï¼š

- **`__enter__`ï¼ˆä¸Šå­¦ï¼‰**ï¼š
  - èƒŒå¥½ä¹¦åŒ…
  - å¸¦å¥½æ–‡å…·
  - è·Ÿå¦ˆå¦ˆè¯´å†è§

- **`__exit__`ï¼ˆæ”¾å­¦ï¼‰**ï¼š
  - æ•´ç†æ¡Œå­
  - æ”¶æ‹¾ä¹¦åŒ…
  - å‘è€å¸ˆè¯´å†è§

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
class ä¸Šå­¦æ—¥:
    def __enter__(self):
        èµ·åºŠ()
        ç©¿è¡£æœ()
        åƒæ—©é¤()
        return å»å­¦æ ¡()

    def __exit__(self, *args):
        æ”¶æ‹¾ä¹¦åŒ…()
        è¯´å†è§()
        å›å®¶()
```

---

### ç±»æ¯”3ï¼šcontextmanager è£…é¥°å™¨

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šGenerator + try-finally

```javascript
// JavaScript Generator
function* timer(name) {
  console.log(`${name} start`);
  const start = Date.now();
  try {
    yield;  // æš‚åœç‚¹
  } finally {
    const elapsed = Date.now() - start;
    console.log(`${name} end (${elapsed}ms)`);
  }
}

// éœ€è¦æ‰‹åŠ¨ç®¡ç†
const gen = timer("operation");
gen.next();  // start
// ... do work ...
gen.next();  // end
```

```python
# Python contextmanager è‡ªåŠ¨ç®¡ç†
from contextlib import contextmanager

@contextmanager
def timer(name):
    print(f"{name} start")
    start = time.time()
    try:
        yield  # with ä»£ç å—åœ¨è¿™é‡Œæ‰§è¡Œ
    finally:
        elapsed = time.time() - start
        print(f"{name} end ({elapsed:.2f}s)")

# è‡ªåŠ¨ç®¡ç†
with timer("operation"):
    # do work
    pass
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šä¸‰æ˜æ²»

contextmanager å°±åƒåšä¸‰æ˜æ²»ï¼š

```
yield å‰ï¼šæ”¾ä¸‹é¢çš„é¢åŒ…ç‰‡
yieldï¼š  æ”¾å¤¹å¿ƒï¼ˆä½ çš„ä»£ç åœ¨è¿™é‡Œï¼‰
yield åï¼šæ”¾ä¸Šé¢çš„é¢åŒ…ç‰‡
```

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
@contextmanager
def åšä¸‰æ˜æ²»():
    æ”¾é¢åŒ…ç‰‡()     # yield å‰
    try:
        yield      # ä½ æ¥æ”¾å¤¹å¿ƒ
    finally:
        å†æ”¾é¢åŒ…ç‰‡()  # yield å
        åˆ‡å¼€()

with åšä¸‰æ˜æ²»():
    æ”¾ç”Ÿèœ()
    æ”¾ç•ªèŒ„()
    æ”¾èŠå£«()
```

---

### ç±»æ¯”4ï¼šExitStack

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šæ‰¹é‡èµ„æºç®¡ç†

```javascript
// JavaScript: æ‰‹åŠ¨ç®¡ç†å¤šä¸ªèµ„æº
const resources = [];
try {
  resources.push(acquire1());
  resources.push(acquire2());
  resources.push(acquire3());
  // use resources
} finally {
  // å¿…é¡»é€†åºé‡Šæ”¾
  resources.reverse().forEach(r => r.release());
}
```

```python
# Python: ExitStack è‡ªåŠ¨ç®¡ç†
from contextlib import ExitStack

with ExitStack() as stack:
    r1 = stack.enter_context(acquire1())
    r2 = stack.enter_context(acquire2())
    r3 = stack.enter_context(acquire3())
    # use resources
# è‡ªåŠ¨é€†åºé‡Šæ”¾
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šå ç§¯æœ¨å’Œæ‹†ç§¯æœ¨

ExitStack å°±åƒå ç§¯æœ¨ï¼š

- **å ç§¯æœ¨**ï¼šä¸€å—ä¸€å—å¾€ä¸Šå ï¼ˆenter_contextï¼‰
- **æ‹†ç§¯æœ¨**ï¼šä»ä¸Šå¾€ä¸‹ä¸€å—å—æ‹¿ä¸‹æ¥ï¼ˆè‡ªåŠ¨é€†åºé€€å‡ºï¼‰

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
with ç§¯æœ¨å¡” as stack:
    stack.å ä¸Šå»(çº¢è‰²ç§¯æœ¨)   # ç¬¬1ä¸ª
    stack.å ä¸Šå»(è“è‰²ç§¯æœ¨)   # ç¬¬2ä¸ª
    stack.å ä¸Šå»(ç»¿è‰²ç§¯æœ¨)   # ç¬¬3ä¸ª
# æ‹†çš„æ—¶å€™ï¼šç»¿ â†’ è“ â†’ çº¢
```

---

### ç±»æ¯”5ï¼šasync with

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šå¼‚æ­¥èµ„æºç®¡ç†

```javascript
// JavaScript: å¼‚æ­¥èµ„æºç®¡ç†
async function main() {
  const conn = await connect();
  try {
    await useConnection(conn);
  } finally {
    await conn.close();
  }
}
```

```python
# Python: async with
async def main():
    async with connect() as conn:
        await use_connection(conn)
    # è‡ªåŠ¨å¼‚æ­¥å…³é—­
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šç­‰å¾…çš„å¼€å…³

async with å°±åƒéœ€è¦ç­‰å¾…çš„å¼€å…³ï¼š

- æ™®é€šå¼€å…³ï¼šæŒ‰ä¸‹ç«‹åˆ»å¼€/å…³
- å¼‚æ­¥å¼€å…³ï¼šæŒ‰ä¸‹åè¦ç­‰ä¸€ä¼šå„¿æ‰çœŸæ­£å¼€/å…³

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
async with é¥æ§æ±½è½¦è¿æ¥():
    # è¿æ¥æ±½è½¦éœ€è¦ç­‰å¾…è“ç‰™é…å¯¹
    await é¥æ§æ±½è½¦.å‰è¿›()
    await é¥æ§æ±½è½¦.åé€€()
# æ–­å¼€è¿æ¥ä¹Ÿéœ€è¦ç­‰å¾…
```

---

### ç±»æ¯”æ€»ç»“è¡¨

| Python æ¦‚å¿µ | JavaScript/React ç±»æ¯” | å°æœ‹å‹ç±»æ¯” |
|------------|---------------------|-----------|
| `with ... as ...:` | try-finally | è¿›æˆ¿é—´å¼€ç¯å‡ºå»å…³ç¯ |
| `__enter__` | componentDidMount | ä¸Šå­¦å‡†å¤‡ |
| `__exit__` | componentWillUnmount | æ”¾å­¦æ”¶æ‹¾ |
| `@contextmanager` | Generator + try-finally | åšä¸‰æ˜æ²» |
| `yield` (contextmanager) | æš‚åœç‚¹ | ä¸‰æ˜æ²»çš„å¤¹å¿ƒ |
| `ExitStack` | æ‰¹é‡èµ„æºç®¡ç† | å ç§¯æœ¨å’Œæ‹†ç§¯æœ¨ |
| `async with` | async try-finally | éœ€è¦ç­‰å¾…çš„å¼€å…³ |
| `suppress` | catch + ignore | å‡è£…æ²¡å¬è§ |
| `nullcontext` | ç©ºæ“ä½œ | ä»€ä¹ˆéƒ½ä¸åšçš„å¼€å…³ |

---

## 6. ã€åç›´è§‰ç‚¹ã€‘

### è¯¯åŒº1ï¼š__exit__ è¿”å› True å°±èƒ½å¤„ç†æ‰€æœ‰å¼‚å¸¸ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**
- `__exit__` è¿”å› True åªæ˜¯**ä¸ä¼ æ’­**å¼‚å¸¸ï¼Œä¸æ˜¯"å¤„ç†"äº†
- èµ„æºå¯èƒ½å¤„äºä¸ä¸€è‡´çŠ¶æ€
- åç»­ä»£ç å¯èƒ½ä¾èµ–å¼‚å¸¸ä¿¡æ¯

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**
å› ä¸ºè¿”å› True åç¨‹åºç»§ç»­è¿è¡Œï¼Œçœ‹èµ·æ¥åƒæ˜¯"å¤„ç†"äº†å¼‚å¸¸ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```python
class BadContext:
    def __enter__(self):
        self.data = []
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # âŒ æ— è„‘åæ‰æ‰€æœ‰å¼‚å¸¸
        return True

with BadContext() as ctx:
    ctx.data.append(1)
    raise ValueError("Something wrong!")
    ctx.data.append(2)  # ä¸ä¼šæ‰§è¡Œ

print(ctx.data)  # [1] - æ•°æ®ä¸å®Œæ•´ï¼

# âœ… æ­£ç¡®åšæ³•ï¼šåªå¤„ç†ç‰¹å®šå¼‚å¸¸ï¼Œè®°å½•æ—¥å¿—
class GoodContext:
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is ValueError:
            logging.warning(f"Caught: {exc_val}")
            return True  # åæ‰ç‰¹å®šå¼‚å¸¸
        return False  # å…¶ä»–å¼‚å¸¸ç»§ç»­ä¼ æ’­
```

---

### è¯¯åŒº2ï¼šcontextmanager çš„ yield åé¢ä¸ä¼šæ‰§è¡Œ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**
- yield åé¢çš„ä»£ç **ä¸€å®šä¼šæ‰§è¡Œ**ï¼ˆåœ¨ finally å—ä¸­ï¼‰
- å³ä½¿ with ä»£ç å—ä¸­æŠ›å‡ºå¼‚å¸¸

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**
å› ä¸ºæ™®é€šç”Ÿæˆå™¨ yield åï¼Œå¦‚æœä¸ç»§ç»­è¿­ä»£ï¼Œåé¢çš„ä»£ç ç¡®å®ä¸ä¼šæ‰§è¡Œã€‚

**æ­£ç¡®ç†è§£ï¼š**

```python
from contextlib import contextmanager

@contextmanager
def demo():
    print("Before yield")
    try:
        yield
    finally:
        print("After yield")  # ä¸€å®šä¼šæ‰§è¡Œï¼

# æ­£å¸¸é€€å‡º
with demo():
    print("Inside with")
# è¾“å‡ºï¼šBefore yield â†’ Inside with â†’ After yield

# å¼‚å¸¸é€€å‡º
with demo():
    print("Inside with")
    raise Exception("Error!")
# è¾“å‡ºï¼šBefore yield â†’ Inside with â†’ After yield â†’ Exception
```

**æ³¨æ„ï¼š** å¦‚æœä¸ç”¨ try-finallyï¼Œå¼‚å¸¸æ—¶ yield åçš„ä»£ç ä¸ä¼šæ‰§è¡Œï¼š

```python
@contextmanager
def bad_demo():
    print("Before yield")
    yield
    print("After yield")  # å¼‚å¸¸æ—¶ä¸ä¼šæ‰§è¡Œï¼

# âŒ é”™è¯¯ï¼šå¼‚å¸¸æ—¶ "After yield" ä¸ä¼šæ‰“å°
```

---

### è¯¯åŒº3ï¼šwith è¯­å¥åªèƒ½ç”¨äºæ–‡ä»¶æ“ä½œ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**
- with æ˜¯**é€šç”¨çš„èµ„æºç®¡ç†æ¨¡å¼**
- ä»»ä½•éœ€è¦"æˆå¯¹æ“ä½œ"çš„åœºæ™¯éƒ½å¯ä»¥ç”¨
- æ–‡ä»¶åªæ˜¯æœ€å¸¸è§çš„ä¾‹å­ä¹‹ä¸€

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**
å› ä¸ºæ•™ç¨‹é€šå¸¸ç”¨æ–‡ä»¶ä½œä¸ºç¬¬ä¸€ä¸ªä¾‹å­ï¼Œç»™äººç•™ä¸‹æ·±åˆ»å°è±¡ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```python
# æ–‡ä»¶æ“ä½œ
with open("file.txt") as f:
    pass

# çº¿ç¨‹é”
import threading
with threading.Lock():
    pass

# æ•°æ®åº“äº‹åŠ¡
with db.begin_transaction():
    pass

# ä¸´æ—¶ä¿®æ”¹
import os
with temp_env_var("DEBUG", "true"):
    pass

# è®¡æ—¶
with timer("operation"):
    pass

# è¿½è¸ª
with trace_as_chain_group("my_chain"):
    pass

# é‡å®šå‘è¾“å‡º
from contextlib import redirect_stdout
with redirect_stdout(buffer):
    pass

# å¿½ç•¥å¼‚å¸¸
from contextlib import suppress
with suppress(FileNotFoundError):
    pass
```

---

## 7. ã€å®æˆ˜ä»£ç ã€‘

```python
"""
ç¤ºä¾‹ï¼šä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ„å»º LangChain é£æ ¼çš„è¿½è¸ªå’Œèµ„æºç®¡ç†ç³»ç»Ÿ
æ¼”ç¤ºåŒæ­¥/å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„å®é™…åº”ç”¨
"""

import time
import asyncio
from contextlib import contextmanager, asynccontextmanager, ExitStack
from typing import Optional, Any, Dict, List
from dataclasses import dataclass, field
from datetime import datetime

# ===== 1. åŸºç¡€ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼šè®¡æ—¶å™¨ =====
print("=== 1. åŸºç¡€è®¡æ—¶å™¨ ===")

class Timer:
    """è®¡æ—¶ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼ˆç±»å®ç°ï¼‰"""

    def __init__(self, name: str = "Operation"):
        self.name = name
        self.start_time: Optional[float] = None
        self.end_time: Optional[float] = None

    def __enter__(self):
        self.start_time = time.time()
        print(f"[{self.name}] Started at {datetime.now().strftime('%H:%M:%S')}")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end_time = time.time()
        elapsed = self.end_time - self.start_time
        status = "completed" if exc_type is None else f"failed ({exc_type.__name__})"
        print(f"[{self.name}] {status.capitalize()} in {elapsed:.3f}s")
        return False  # ä¸åå¼‚å¸¸

    @property
    def elapsed(self) -> float:
        if self.start_time and self.end_time:
            return self.end_time - self.start_time
        return 0.0

with Timer("File Processing") as t:
    time.sleep(0.5)
print(f"Elapsed: {t.elapsed:.3f}s")

# ===== 2. contextmanager è£…é¥°å™¨æ–¹å¼ =====
print("\n=== 2. contextmanager è£…é¥°å™¨ ===")

@contextmanager
def temp_config(key: str, value: Any):
    """ä¸´æ—¶ä¿®æ”¹é…ç½®"""
    config = {"model": "gpt-4", "temperature": 0.7}
    old_value = config.get(key)
    print(f"Setting {key} = {value} (was {old_value})")
    config[key] = value
    try:
        yield config
    finally:
        print(f"Restoring {key} = {old_value}")
        config[key] = old_value

with temp_config("temperature", 0.0) as cfg:
    print(f"Current config: {cfg}")

# ===== 3. è¿½è¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨ =====
print("\n=== 3. è¿½è¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨ ===")

@dataclass
class TraceSpan:
    """è¿½è¸ªè·¨åº¦"""
    name: str
    start_time: float = field(default_factory=time.time)
    end_time: Optional[float] = None
    children: List['TraceSpan'] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def end(self):
        self.end_time = time.time()

    @property
    def duration(self) -> float:
        if self.end_time:
            return self.end_time - self.start_time
        return 0.0

class Tracer:
    """ç®€å•çš„è¿½è¸ªå™¨"""
    _current_span: Optional[TraceSpan] = None
    _root_spans: List[TraceSpan] = []

    @classmethod
    @contextmanager
    def span(cls, name: str, **metadata):
        """åˆ›å»ºè¿½è¸ªè·¨åº¦"""
        span = TraceSpan(name=name, metadata=metadata)
        parent = cls._current_span

        if parent:
            parent.children.append(span)
        else:
            cls._root_spans.append(span)

        cls._current_span = span
        print(f"[TRACE] â†’ Enter: {name}")

        try:
            yield span
        finally:
            span.end()
            cls._current_span = parent
            print(f"[TRACE] â† Exit: {name} ({span.duration:.3f}s)")

    @classmethod
    def print_traces(cls):
        def print_span(span: TraceSpan, indent: int = 0):
            prefix = "  " * indent
            print(f"{prefix}â”œâ”€ {span.name}: {span.duration:.3f}s")
            for child in span.children:
                print_span(child, indent + 1)

        print("\n=== Trace Summary ===")
        for span in cls._root_spans:
            print_span(span)

# ä½¿ç”¨è¿½è¸ªå™¨
with Tracer.span("Main Chain", model="gpt-4"):
    with Tracer.span("Prompt Template"):
        time.sleep(0.1)
    with Tracer.span("LLM Call"):
        time.sleep(0.3)
    with Tracer.span("Output Parser"):
        time.sleep(0.05)

Tracer.print_traces()

# ===== 4. å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ =====
print("\n=== 4. å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ ===")

class AsyncResource:
    """å¼‚æ­¥èµ„æº"""

    def __init__(self, name: str):
        self.name = name
        self.connected = False

    async def __aenter__(self):
        print(f"[Async] Connecting to {self.name}...")
        await asyncio.sleep(0.1)
        self.connected = True
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print(f"[Async] Disconnecting from {self.name}...")
        await asyncio.sleep(0.05)
        self.connected = False
        return False

async def demo_async_context():
    async with AsyncResource("Database") as db:
        print(f"[Async] Connected: {db.connected}")
        await asyncio.sleep(0.2)

asyncio.run(demo_async_context())

# ===== 5. asynccontextmanager è£…é¥°å™¨ =====
print("\n=== 5. asynccontextmanager è£…é¥°å™¨ ===")

@asynccontextmanager
async def async_tracer(name: str):
    """å¼‚æ­¥è¿½è¸ªä¸Šä¸‹æ–‡"""
    print(f"[Async Trace] â†’ {name}")
    start = time.time()
    try:
        yield
    finally:
        elapsed = time.time() - start
        print(f"[Async Trace] â† {name} ({elapsed:.3f}s)")

async def demo_async_tracer():
    async with async_tracer("Async Chain"):
        async with async_tracer("Async LLM Call"):
            await asyncio.sleep(0.2)
        async with async_tracer("Async Post Process"):
            await asyncio.sleep(0.1)

asyncio.run(demo_async_tracer())

# ===== 6. ExitStack ç®¡ç†å¤šä¸ªèµ„æº =====
print("\n=== 6. ExitStack ===")

@contextmanager
def managed_file(name: str):
    print(f"Opening: {name}")
    try:
        yield f"<file:{name}>"
    finally:
        print(f"Closing: {name}")

with ExitStack() as stack:
    files = []
    for name in ["config.yaml", "data.json", "model.pkl"]:
        files.append(stack.enter_context(managed_file(name)))

    print(f"Working with: {files}")
    # æ‰€æœ‰æ–‡ä»¶éƒ½ä¼šè¢«æ­£ç¡®å…³é—­ï¼ˆé€†åºï¼‰

# ===== 7. å›è°ƒæ³¨å†Œ =====
print("\n=== 7. å›è°ƒæ³¨å†Œ ===")

def on_cleanup(resource_name: str):
    print(f"Cleanup callback: {resource_name}")

with ExitStack() as stack:
    # æ³¨å†Œæ¸…ç†å›è°ƒ
    stack.callback(on_cleanup, "database")
    stack.callback(on_cleanup, "cache")
    stack.callback(on_cleanup, "logger")

    print("Doing work...")
# è¾“å‡ºï¼šé€†åºæ‰§è¡Œå›è°ƒ

# ===== 8. å®é™…åº”ç”¨ï¼šLangChain é£æ ¼è¿½è¸ª =====
print("\n=== 8. LangChain é£æ ¼è¿½è¸ª ===")

@dataclass
class RunInfo:
    """è¿è¡Œä¿¡æ¯"""
    run_id: str
    name: str
    inputs: Dict[str, Any]
    outputs: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    start_time: float = field(default_factory=time.time)
    end_time: Optional[float] = None

class CallbackManager:
    """å›è°ƒç®¡ç†å™¨"""

    def __init__(self):
        self.runs: List[RunInfo] = []

    @contextmanager
    def trace(self, name: str, inputs: Dict[str, Any]):
        """è¿½è¸ªä¸€æ¬¡è¿è¡Œ"""
        import uuid
        run_id = str(uuid.uuid4())[:8]
        run_info = RunInfo(run_id=run_id, name=name, inputs=inputs)
        self.runs.append(run_info)

        print(f"[{run_id}] Started: {name}")
        try:
            yield run_info
            run_info.outputs = {"status": "success"}
            print(f"[{run_id}] Completed: {name}")
        except Exception as e:
            run_info.error = str(e)
            print(f"[{run_id}] Failed: {name} - {e}")
            raise
        finally:
            run_info.end_time = time.time()

    def summary(self):
        print("\n=== Run Summary ===")
        for run in self.runs:
            duration = (run.end_time - run.start_time) if run.end_time else 0
            status = "âœ“" if run.outputs else "âœ—"
            print(f"{status} [{run.run_id}] {run.name}: {duration:.3f}s")

callback_manager = CallbackManager()

with callback_manager.trace("RAG Pipeline", {"query": "What is LangChain?"}):
    with callback_manager.trace("Retriever", {"query": "What is LangChain?"}):
        time.sleep(0.1)
    with callback_manager.trace("LLM", {"context": "..."}):
        time.sleep(0.2)
    with callback_manager.trace("Parser", {"response": "..."}):
        time.sleep(0.05)

callback_manager.summary()

# ===== 9. æ¡ä»¶ä¸Šä¸‹æ–‡ç®¡ç†å™¨ =====
print("\n=== 9. æ¡ä»¶ä¸Šä¸‹æ–‡ç®¡ç†å™¨ ===")

from contextlib import nullcontext

def process_with_optional_lock(data: str, use_lock: bool = False):
    """å¯é€‰çš„é”"""
    import threading
    lock = threading.Lock() if use_lock else nullcontext()

    with lock:
        print(f"Processing: {data} (locked: {use_lock})")
        return data.upper()

process_with_optional_lock("hello", use_lock=True)
process_with_optional_lock("world", use_lock=False)

# ===== 10. å¼‚å¸¸å¤„ç†ä¸Šä¸‹æ–‡ =====
print("\n=== 10. å¼‚å¸¸å¤„ç† ===")

from contextlib import suppress

# å¿½ç•¥ç‰¹å®šå¼‚å¸¸
with suppress(FileNotFoundError, PermissionError):
    print("Trying to remove file...")
    # open("nonexistent.txt")  # ä¼šè¢«å¿½ç•¥

# è‡ªå®šä¹‰å¼‚å¸¸å¤„ç†
@contextmanager
def error_boundary(error_handler):
    """é”™è¯¯è¾¹ç•Œ"""
    try:
        yield
    except Exception as e:
        error_handler(e)

def my_error_handler(e):
    print(f"Caught error: {type(e).__name__}: {e}")

with error_boundary(my_error_handler):
    raise ValueError("Test error")
print("Continues after error")
```

**è¿è¡Œè¾“å‡ºç¤ºä¾‹ï¼š**
```
=== 1. åŸºç¡€è®¡æ—¶å™¨ ===
[File Processing] Started at 14:30:25
[File Processing] Completed in 0.501s
Elapsed: 0.501s

=== 2. contextmanager è£…é¥°å™¨ ===
Setting temperature = 0.0 (was 0.7)
Current config: {'model': 'gpt-4', 'temperature': 0.0}
Restoring temperature = 0.7

=== 3. è¿½è¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨ ===
[TRACE] â†’ Enter: Main Chain
[TRACE] â†’ Enter: Prompt Template
[TRACE] â† Exit: Prompt Template (0.100s)
[TRACE] â†’ Enter: LLM Call
[TRACE] â† Exit: LLM Call (0.300s)
[TRACE] â†’ Enter: Output Parser
[TRACE] â† Exit: Output Parser (0.050s)
[TRACE] â† Exit: Main Chain (0.453s)

=== Trace Summary ===
â”œâ”€ Main Chain: 0.453s
  â”œâ”€ Prompt Template: 0.100s
  â”œâ”€ LLM Call: 0.300s
  â”œâ”€ Output Parser: 0.050s

=== 8. LangChain é£æ ¼è¿½è¸ª ===
[abc12345] Started: RAG Pipeline
[def67890] Started: Retriever
[def67890] Completed: Retriever
[ghi11111] Started: LLM
[ghi11111] Completed: LLM
[jkl22222] Started: Parser
[jkl22222] Completed: Parser
[abc12345] Completed: RAG Pipeline

=== Run Summary ===
âœ“ [abc12345] RAG Pipeline: 0.358s
âœ“ [def67890] Retriever: 0.101s
âœ“ [ghi11111] LLM: 0.201s
âœ“ [jkl22222] Parser: 0.051s
```

---

## 8. ã€é¢è¯•å¿…é—®ã€‘

### é—®é¢˜ï¼š"ä»€ä¹ˆæ˜¯ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Ÿä»€ä¹ˆæ—¶å€™ç”¨å®ƒï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**
"ä¸Šä¸‹æ–‡ç®¡ç†å™¨å°±æ˜¯ with è¯­å¥ç”¨çš„ä¸œè¥¿ï¼Œå¯ä»¥è‡ªåŠ¨å…³é—­æ–‡ä»¶ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ˜¯ Python çš„èµ„æºç®¡ç†åè®®**ï¼Œé€šè¿‡ `__enter__` å’Œ `__exit__` ä¸¤ä¸ªæ–¹æ³•å®ç°"è¿›å…¥æ—¶å‡†å¤‡ã€é€€å‡ºæ—¶æ¸…ç†"çš„æ¨¡å¼ã€‚
>
> **ä½¿ç”¨åœºæ™¯**ï¼ˆä¸ä»…æ˜¯æ–‡ä»¶ï¼‰ï¼š
> 1. **èµ„æºç®¡ç†**ï¼šæ–‡ä»¶ã€æ•°æ®åº“è¿æ¥ã€ç½‘ç»œè¿æ¥
> 2. **é”å’ŒåŒæ­¥**ï¼šthreading.Lockã€asyncio.Lock
> 3. **äº‹åŠ¡**ï¼šæ•°æ®åº“äº‹åŠ¡ã€åˆ†å¸ƒå¼äº‹åŠ¡
> 4. **ä¸´æ—¶çŠ¶æ€**ï¼šä¸´æ—¶ä¿®æ”¹é…ç½®ã€ç¯å¢ƒå˜é‡
> 5. **è¿½è¸ªå’Œç›‘æ§**ï¼šè®¡æ—¶ã€æ—¥å¿—ã€æ€§èƒ½è¿½è¸ª
>
> **å®ç°æ–¹å¼**ï¼š
> ```python
> # æ–¹å¼1ï¼šç±»å®ç°
> class MyContext:
>     def __enter__(self): return self
>     def __exit__(self, *args): pass
>
> # æ–¹å¼2ï¼šcontextmanager è£…é¥°å™¨
> @contextmanager
> def my_context():
>     try:
>         yield
>     finally:
>         pass
> ```
>
> **åœ¨ LangChain ä¸­çš„åº”ç”¨**ï¼š`trace_as_chain_group` ä¸Šä¸‹æ–‡ç®¡ç†å™¨ç”¨äºè¿½è¸ª Chain çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œæ”¶é›†å›è°ƒä¿¡æ¯ã€‚
>
> **æ ¸å¿ƒä»·å€¼**ï¼šä¿è¯"æœ‰å§‹æœ‰ç»ˆ"â€”â€”å³ä½¿å‡ºç°å¼‚å¸¸ï¼Œæ¸…ç†ä»£ç ä¹Ÿä¸€å®šä¼šæ‰§è¡Œã€‚

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… è¯´æ˜äº†åè®®æœ¬è´¨
2. âœ… åˆ—ä¸¾äº†å¤šç§ä½¿ç”¨åœºæ™¯
3. âœ… ç»™å‡ºäº†ä¸¤ç§å®ç°æ–¹å¼
4. âœ… è”ç³»äº† LangChain å®é™…åº”ç”¨

---

### é—®é¢˜ï¼š"`__exit__` çš„è¿”å›å€¼æœ‰ä»€ä¹ˆç”¨ï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**
"è¿”å› True è¡¨ç¤ºå¤„ç†äº†å¼‚å¸¸ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **`__exit__` çš„è¿”å›å€¼å†³å®šå¼‚å¸¸æ˜¯å¦ç»§ç»­ä¼ æ’­**ï¼š
>
> - è¿”å› `False` æˆ– `None`ï¼šå¼‚å¸¸ç»§ç»­å‘ä¸Šä¼ æ’­ï¼ˆé»˜è®¤è¡Œä¸ºï¼‰
> - è¿”å› `True`ï¼šå¼‚å¸¸è¢«"åæ‰"ï¼Œç¨‹åºç»§ç»­æ‰§è¡Œ
>
> **å‚æ•°è¯¦è§£**ï¼š
> ```python
> def __exit__(self, exc_type, exc_val, exc_tb):
>     # exc_type: å¼‚å¸¸ç±»å‹ï¼ˆå¦‚ ValueErrorï¼‰
>     # exc_val: å¼‚å¸¸å®ä¾‹
>     # exc_tb: è¿½æº¯ä¿¡æ¯
>     # å¦‚æœæ²¡æœ‰å¼‚å¸¸ï¼Œä¸‰ä¸ªå‚æ•°éƒ½æ˜¯ None
> ```
>
> **æœ€ä½³å®è·µ**ï¼š
> - é€šå¸¸è¿”å› `False`ï¼Œè®©å¼‚å¸¸æ­£å¸¸ä¼ æ’­
> - åªæœ‰æ˜ç¡®çŸ¥é“å¦‚ä½•å¤„ç†æ—¶æ‰è¿”å› `True`
> - è¿”å› `True` å‰åº”è¯¥è®°å½•æ—¥å¿—æˆ–é‡‡å–è¡¥æ•‘æªæ–½
>
> ```python
> def __exit__(self, exc_type, exc_val, exc_tb):
>     if exc_type is ValueError:
>         logging.warning(f"Caught: {exc_val}")
>         return True  # åªåæ‰ ValueError
>     return False  # å…¶ä»–å¼‚å¸¸ç»§ç»­ä¼ æ’­
> ```

---

## 9. ã€åŒ–éª¨ç»µæŒã€‘

### å¡ç‰‡1ï¼šä»€ä¹ˆæ˜¯ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Ÿ ğŸ¯

**ä¸€å¥è¯ï¼š** ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ˜¯å®ç°äº† `__enter__` å’Œ `__exit__` çš„å¯¹è±¡ï¼Œç”¨äºè‡ªåŠ¨ç®¡ç†èµ„æºã€‚

**ä¸¾ä¾‹ï¼š**
```python
with open("file.txt") as f:
    content = f.read()
# è‡ªåŠ¨å…³é—­æ–‡ä»¶
```

**åº”ç”¨ï¼š** LangChain çš„è¿½è¸ªä¸Šä¸‹æ–‡ã€å›è°ƒç®¡ç†éƒ½ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨ã€‚

---

### å¡ç‰‡2ï¼š__enter__ å’Œ __exit__ ğŸ“

**ä¸€å¥è¯ï¼š** `__enter__` åœ¨è¿›å…¥ with æ—¶æ‰§è¡Œï¼Œ`__exit__` åœ¨é€€å‡ºæ—¶æ‰§è¡Œï¼ˆæ— è®ºæ˜¯å¦å‡ºé”™ï¼‰ã€‚

**ä¸¾ä¾‹ï¼š**
```python
class MyContext:
    def __enter__(self):
        print("Enter")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Exit")
        return False
```

**åº”ç”¨ï¼š** ç†è§£è¿™ä¸ªåè®®å°±èƒ½è¯»æ‡‚ä»»ä½•ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„ä»£ç ã€‚

---

### å¡ç‰‡3ï¼šcontextmanager è£…é¥°å™¨ ğŸ”§

**ä¸€å¥è¯ï¼š** ç”¨ `@contextmanager` å’Œ yield å¯ä»¥ç®€åŒ–ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„å®ç°ã€‚

**ä¸¾ä¾‹ï¼š**
```python
from contextlib import contextmanager

@contextmanager
def timer():
    start = time.time()
    try:
        yield
    finally:
        print(f"Elapsed: {time.time() - start}s")
```

**åº”ç”¨ï¼š** LangChain çš„ trace_as_chain_group å°±æ˜¯è¿™æ ·å®ç°çš„ã€‚

---

### å¡ç‰‡4ï¼šyield çš„åˆ†å‰²ä½œç”¨ âœ‚ï¸

**ä¸€å¥è¯ï¼š** yield å‰æ˜¯ `__enter__`ï¼Œyield åæ˜¯ `__exit__`ï¼Œyield çš„å€¼æ˜¯ as åçš„å˜é‡ã€‚

**ä¸¾ä¾‹ï¼š**
```python
@contextmanager
def demo():
    print("Before")  # __enter__
    yield "value"    # as åçš„å˜é‡
    print("After")   # __exit__
```

**åº”ç”¨ï¼š** ç†è§£ yield çš„åˆ†å‰²ä½œç”¨å°±èƒ½å†™å‡ºæ­£ç¡®çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨ã€‚

---

### å¡ç‰‡5ï¼štry-finally ä¿è¯æ‰§è¡Œ ğŸ”’

**ä¸€å¥è¯ï¼š** contextmanager ä¸­çš„ yield å¿…é¡»æ”¾åœ¨ try å—é‡Œï¼Œæ¸…ç†ä»£ç æ”¾åœ¨ finally å—é‡Œã€‚

**ä¸¾ä¾‹ï¼š**
```python
@contextmanager
def safe_context():
    resource = acquire()
    try:
        yield resource
    finally:
        release(resource)  # ä¸€å®šä¼šæ‰§è¡Œï¼
```

**åº”ç”¨ï¼š** ä¿è¯èµ„æºé‡Šæ”¾ï¼Œå³ä½¿å‡ºç°å¼‚å¸¸ã€‚

---

### å¡ç‰‡6ï¼šasync with å¼‚æ­¥ä¸Šä¸‹æ–‡ âš¡

**ä¸€å¥è¯ï¼š** async with ç”¨äºå¼‚æ­¥èµ„æºç®¡ç†ï¼Œéœ€è¦å®ç° `__aenter__` å’Œ `__aexit__`ã€‚

**ä¸¾ä¾‹ï¼š**
```python
async with aiohttp.ClientSession() as session:
    async with session.get(url) as response:
        data = await response.text()
```

**åº”ç”¨ï¼š** LangChain çš„å¼‚æ­¥è¿½è¸ªä½¿ç”¨ async withã€‚

---

### å¡ç‰‡7ï¼šExitStack ç®¡ç†å¤šä¸ªèµ„æº ğŸ“š

**ä¸€å¥è¯ï¼š** ExitStack å¯ä»¥åŠ¨æ€ç®¡ç†å¤šä¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œé€†åºæ¸…ç†ã€‚

**ä¸¾ä¾‹ï¼š**
```python
from contextlib import ExitStack

with ExitStack() as stack:
    files = [stack.enter_context(open(f)) for f in filenames]
```

**åº”ç”¨ï¼š** æ‰“å¼€ä¸ç¡®å®šæ•°é‡çš„èµ„æºæ—¶ä½¿ç”¨ã€‚

---

### å¡ç‰‡8ï¼šsuppress å¿½ç•¥å¼‚å¸¸ ğŸ”‡

**ä¸€å¥è¯ï¼š** suppress ä¸Šä¸‹æ–‡ç®¡ç†å™¨å¯ä»¥é™é»˜å¿½ç•¥ç‰¹å®šå¼‚å¸¸ã€‚

**ä¸¾ä¾‹ï¼š**
```python
from contextlib import suppress

with suppress(FileNotFoundError):
    os.remove("maybe_exists.txt")
```

**åº”ç”¨ï¼š** æ¸…ç†å¯èƒ½ä¸å­˜åœ¨çš„èµ„æºæ—¶ä½¿ç”¨ã€‚

---

### å¡ç‰‡9ï¼šnullcontext ç©ºæ“ä½œ ğŸš«

**ä¸€å¥è¯ï¼š** nullcontext æ˜¯ä»€ä¹ˆéƒ½ä¸åšçš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œç”¨äºå¯é€‰çš„ä¸Šä¸‹æ–‡ã€‚

**ä¸¾ä¾‹ï¼š**
```python
from contextlib import nullcontext

lock = threading.Lock() if need_lock else nullcontext()
with lock:
    do_work()
```

**åº”ç”¨ï¼š** å®ç°å¯é€‰çš„é”ã€è¿½è¸ªç­‰åŠŸèƒ½ã€‚

---

### å¡ç‰‡10ï¼šåœ¨ LangChain æºç ä¸­çš„åº”ç”¨ â­

**ä¸€å¥è¯ï¼š** LangChain ä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨å®ç°è¿½è¸ªã€å›è°ƒç®¡ç†ã€èµ„æºæ§åˆ¶ã€‚

**ä¸¾ä¾‹ï¼š**
```python
# langchain è¿½è¸ªæ¨¡å¼
with trace_as_chain_group("my_chain"):
    result = chain.invoke(input)

# å¼‚æ­¥è¿½è¸ª
async with atrace_as_chain_group("async_chain"):
    result = await chain.ainvoke(input)
```

**åº”ç”¨ï¼š** ç†è§£ä¸Šä¸‹æ–‡ç®¡ç†å™¨å°±èƒ½ç†è§£ LangChain çš„è¿½è¸ªæœºåˆ¶ã€‚

---

## 10. ã€ä¸€å¥è¯æ€»ç»“ã€‘

**ä¸Šä¸‹æ–‡ç®¡ç†å™¨æ˜¯ Python çš„èµ„æºç®¡ç†åè®®ï¼Œé€šè¿‡ `__enter__`/`__exit__` æˆ– @contextmanager å®ç°"è¿›å…¥æ—¶å‡†å¤‡ã€é€€å‡ºæ—¶æ¸…ç†"ï¼Œé…åˆ with è¯­å¥ä¿è¯èµ„æºå®‰å…¨é‡Šæ”¾ï¼Œæ˜¯ LangChain å®ç°è¿½è¸ªã€å›è°ƒã€èµ„æºç®¡ç†çš„åŸºç¡€è®¾æ–½ã€‚**

---

## ğŸ“š å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£ with è¯­å¥çš„æ‰§è¡Œæµç¨‹
- [ ] ä¼šç”¨ç±»å®ç° `__enter__` å’Œ `__exit__`
- [ ] ä¼šç”¨ @contextmanager è£…é¥°å™¨
- [ ] ç†è§£ yield åœ¨ contextmanager ä¸­çš„ä½œç”¨
- [ ] çŸ¥é“ try-finally ä¿è¯æ¸…ç†ä»£ç æ‰§è¡Œ
- [ ] ä¼šä½¿ç”¨ async with å’Œ asynccontextmanager
- [ ] äº†è§£ ExitStackã€suppressã€nullcontext çš„ç”¨æ³•

## ğŸ”— ä¸‹ä¸€æ­¥å­¦ä¹ 

- **Callback å›è°ƒç³»ç»Ÿ**ï¼šLangChain çš„å›è°ƒæœºåˆ¶
- **Runnable åè®®**ï¼šLangChain çš„æ ¸å¿ƒæŠ½è±¡
- **å¼‚æ­¥ç¼–ç¨‹**ï¼šasync/await æ·±å…¥ç†è§£

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2025-01-14
