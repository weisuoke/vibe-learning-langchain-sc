# è£…é¥°å™¨ä¸å…ƒç±»

> åŸå­åŒ–çŸ¥è¯†ç‚¹ | Pythoné«˜çº§ç‰¹æ€§ | LangChain æºç å­¦ä¹ å‰ç½®çŸ¥è¯†

---

## 1. ã€30å­—æ ¸å¿ƒã€‘

**è£…é¥°å™¨æ˜¯ä¸ä¿®æ”¹åŸå‡½æ•°ä»£ç è€Œå¢å¼ºå…¶åŠŸèƒ½çš„è¯­æ³•ç³–ï¼Œå…ƒç±»æ˜¯åˆ›å»ºç±»çš„ç±»ï¼Œæ˜¯ LangChain æ‰©å±•æœºåˆ¶çš„åŸºç¡€ã€‚**

---

## 2. ã€ç¬¬ä¸€æ€§åŸç†ã€‘

### ä»€ä¹ˆæ˜¯ç¬¬ä¸€æ€§åŸç†ï¼Ÿ

**ç¬¬ä¸€æ€§åŸç†**ï¼šå›åˆ°äº‹ç‰©æœ€åŸºæœ¬çš„çœŸç†ï¼Œä»æºå¤´æ€è€ƒé—®é¢˜

### è£…é¥°å™¨çš„ç¬¬ä¸€æ€§åŸç† ğŸ¯

#### 1. æœ€åŸºç¡€çš„å®šä¹‰

**è£…é¥°å™¨ = æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°ï¼Œè¿”å›æ–°å‡½æ•°çš„å‡½æ•°**

ä»…æ­¤è€Œå·²ï¼æ²¡æœ‰æ›´åŸºç¡€çš„äº†ã€‚

```python
# è£…é¥°å™¨çš„æœ¬è´¨
def decorator(func):
    def wrapper(*args, **kwargs):
        # åœ¨åŸå‡½æ•°æ‰§è¡Œå‰/åæ·»åŠ åŠŸèƒ½
        return func(*args, **kwargs)
    return wrapper

# @decorator åªæ˜¯è¯­æ³•ç³–
@decorator
def my_func():
    pass

# ç­‰ä»·äº
my_func = decorator(my_func)
```

#### 2. ä¸ºä»€ä¹ˆéœ€è¦è£…é¥°å™¨ï¼Ÿ

**æ ¸å¿ƒé—®é¢˜ï¼šæƒ³åœ¨ä¸ä¿®æ”¹åŸå‡½æ•°ä»£ç çš„æƒ…å†µä¸‹ï¼Œç»™å®ƒæ·»åŠ åŠŸèƒ½**

```python
# ä¸ç”¨è£…é¥°å™¨ï¼šé‡å¤ä»£ç 
def func1():
    print("å¼€å§‹æ‰§è¡Œ")  # é‡å¤
    # åŸå§‹é€»è¾‘
    print("æ‰§è¡Œå®Œæˆ")  # é‡å¤

def func2():
    print("å¼€å§‹æ‰§è¡Œ")  # é‡å¤
    # åŸå§‹é€»è¾‘
    print("æ‰§è¡Œå®Œæˆ")  # é‡å¤

# ç”¨è£…é¥°å™¨ï¼šä¸€æ¬¡å®šä¹‰ï¼Œå¤šå¤„å¤ç”¨
@log_execution
def func1():
    # åŸå§‹é€»è¾‘

@log_execution
def func2():
    # åŸå§‹é€»è¾‘
```

#### 3. è£…é¥°å™¨çš„ä¸‰å±‚ä»·å€¼

##### ä»·å€¼1ï¼šä»£ç å¤ç”¨ï¼ˆDRY åŸåˆ™ï¼‰

```python
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f"{func.__name__} è€—æ—¶: {time.time() - start:.2f}ç§’")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)

@timer
def another_function():
    time.sleep(0.5)
```

##### ä»·å€¼2ï¼šå…³æ³¨ç‚¹åˆ†ç¦»

```python
# åŸå§‹é€»è¾‘å’Œè¾…åŠ©é€»è¾‘åˆ†ç¦»
@validate_input   # éªŒè¯é€»è¾‘
@cache_result     # ç¼“å­˜é€»è¾‘
@log_call         # æ—¥å¿—é€»è¾‘
def process_data(data):
    # åªå…³æ³¨æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
    return transform(data)
```

##### ä»·å€¼3ï¼šå£°æ˜å¼ç¼–ç¨‹

```python
# å£°æ˜å¼ï¼šè¯´æ˜"æ˜¯ä»€ä¹ˆ"
@abstractmethod
def invoke(self, input): ...

@property
def name(self): ...

@field_validator('age')
def validate_age(cls, v): ...
```

#### 4. å…ƒç±»çš„ç¬¬ä¸€æ€§åŸç†

**å…ƒç±» = ç±»çš„ç±»ï¼Œæ§åˆ¶ç±»çš„åˆ›å»ºè¿‡ç¨‹**

```
å®ä¾‹ â†’ ç±» â†’ å…ƒç±»
å¯¹è±¡ â†’ class â†’ type

type æ˜¯æ‰€æœ‰ç±»çš„å…ƒç±»ï¼ˆåŒ…æ‹¬å®ƒè‡ªå·±ï¼‰
```

```python
class MyClass:
    pass

# MyClass æ˜¯ type çš„å®ä¾‹
print(type(MyClass))  # <class 'type'>
print(type(type))     # <class 'type'>

# ç­‰ä»·å†™æ³•
MyClass = type('MyClass', (), {})
```

#### 5. ä»ç¬¬ä¸€æ€§åŸç†æ¨å¯¼ LangChain æºç åº”ç”¨

**æ¨ç†é“¾ï¼š**

```
1. LangChain éœ€è¦åœ¨ä¸ä¿®æ”¹æºç çš„æƒ…å†µä¸‹å¢å¼ºåŠŸèƒ½
   â†“
2. è£…é¥°å™¨å¯ä»¥åŒ…è£…å‡½æ•°/æ–¹æ³•ï¼Œæ·»åŠ æ—¥å¿—ã€éªŒè¯ã€ç¼“å­˜
   â†“
3. @abstractmethod å®šä¹‰æ¥å£è§„èŒƒ
   â†“
4. @property å®ç°å±æ€§è®¿é—®æ§åˆ¶
   â†“
5. Pydantic çš„ @field_validator å®ç°éªŒè¯é€»è¾‘
   â†“
6. å…ƒç±»ç”¨äºæ³¨å†Œç»„ä»¶ã€è‡ªåŠ¨æ”¶é›†ä¿¡æ¯
```

#### 6. ä¸€å¥è¯æ€»ç»“ç¬¬ä¸€æ€§åŸç†

**è£…é¥°å™¨æ˜¯é«˜é˜¶å‡½æ•°çš„è¯­æ³•ç³–ï¼Œè®©æˆ‘ä»¬å¯ä»¥æ— ä¾µå…¥åœ°å¢å¼ºå‡½æ•°åŠŸèƒ½ï¼›å…ƒç±»æ˜¯ç±»çš„å·¥å‚ï¼Œæ§åˆ¶ç±»çš„åˆ›å»ºè¡Œä¸ºï¼Œä¸¤è€…æ˜¯ Python å…ƒç¼–ç¨‹çš„æ ¸å¿ƒã€‚**

---

## 3. ã€æ ¸å¿ƒæ¦‚å¿µï¼ˆå…¨é¢è¦†ç›–ï¼‰ã€‘

### æ ¸å¿ƒæ¦‚å¿µ1ï¼šå‡½æ•°è£…é¥°å™¨ ğŸ·ï¸

**è£…é¥°å™¨æ˜¯æ¥å—å‡½æ•°ã€è¿”å›å‡½æ•°çš„å¯è°ƒç”¨å¯¹è±¡**

```python
import functools
import time

# åŸºç¡€è£…é¥°å™¨æ¨¡æ¿
def my_decorator(func):
    @functools.wraps(func)  # ä¿ç•™åŸå‡½æ•°å…ƒä¿¡æ¯
    def wrapper(*args, **kwargs):
        # å‰ç½®å¤„ç†
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        # åç½®å¤„ç†
        print(f"Finished {func.__name__}")
        return result
    return wrapper

@my_decorator
def greet(name: str) -> str:
    """é—®å€™å‡½æ•°"""
    return f"Hello, {name}!"

# è°ƒç”¨
result = greet("Alice")
print(result)
print(greet.__name__)  # "greet"ï¼ˆå› ä¸ºç”¨äº† functools.wrapsï¼‰
print(greet.__doc__)   # "é—®å€™å‡½æ•°"
```

**å¸¸è§å†…ç½®è£…é¥°å™¨ï¼š**

| è£…é¥°å™¨ | ä½œç”¨ | ç¤ºä¾‹ |
|-------|------|------|
| `@property` | å°†æ–¹æ³•å˜æˆå±æ€§ | `obj.name` è€Œä¸æ˜¯ `obj.name()` |
| `@classmethod` | ç±»æ–¹æ³•ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç±» | `cls.create()` |
| `@staticmethod` | é™æ€æ–¹æ³•ï¼Œæ—  self/cls | å·¥å…·å‡½æ•° |
| `@abstractmethod` | æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å¿…é¡»å®ç° | æ¥å£å®šä¹‰ |
| `@functools.wraps` | ä¿ç•™åŸå‡½æ•°å…ƒä¿¡æ¯ | è£…é¥°å™¨å†…éƒ¨ä½¿ç”¨ |
| `@functools.lru_cache` | ç¼“å­˜å‡½æ•°ç»“æœ | è®°å¿†åŒ– |

**åœ¨ LangChain æºç ä¸­çš„åº”ç”¨ï¼š**

```python
# langchain_core/runnables/base.py
from abc import ABC, abstractmethod

class Runnable(ABC):
    @abstractmethod
    def invoke(self, input, config=None):
        """å­ç±»å¿…é¡»å®ç°çš„æ–¹æ³•"""
        ...

    @property
    def InputType(self):
        """è¾“å…¥ç±»å‹ï¼ˆå±æ€§è®¿é—®ï¼‰"""
        return Any
```

---

### æ ¸å¿ƒæ¦‚å¿µ2ï¼šå¸¦å‚æ•°çš„è£…é¥°å™¨ï¼ˆè£…é¥°å™¨å·¥å‚ï¼‰ ğŸ“

**è£…é¥°å™¨å·¥å‚æ˜¯è¿”å›è£…é¥°å™¨çš„å‡½æ•°**

```python
import functools

def repeat(times: int):
    """è£…é¥°å™¨å·¥å‚ï¼šé‡å¤æ‰§è¡Œå‡½æ•°æŒ‡å®šæ¬¡æ•°"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            results = []
            for _ in range(times):
                results.append(func(*args, **kwargs))
            return results
        return wrapper
    return decorator

@repeat(times=3)
def greet(name: str) -> str:
    return f"Hello, {name}!"

print(greet("Alice"))  # ['Hello, Alice!', 'Hello, Alice!', 'Hello, Alice!']
```

**ç†è§£ä¸‰å±‚åµŒå¥—ï¼š**

```python
# @repeat(times=3) å±•å¼€è¿‡ç¨‹ï¼š

# 1. è°ƒç”¨ repeat(times=3)ï¼Œè¿”å› decorator å‡½æ•°
# 2. @decorator åº”ç”¨åˆ° greet
# 3. greet = decorator(greet)ï¼Œè¿”å› wrapper
# 4. è°ƒç”¨ greet() å®é™…æ‰§è¡Œ wrapper()

# æ›´æ¸…æ™°çš„å†™æ³•ï¼š
decorator = repeat(times=3)  # è·å–è£…é¥°å™¨
greet = decorator(greet)     # åº”ç”¨è£…é¥°å™¨
```

**å®ç”¨ç¤ºä¾‹ï¼šé‡è¯•è£…é¥°å™¨**

```python
import functools
import time

def retry(max_attempts: int = 3, delay: float = 1.0):
    """é‡è¯•è£…é¥°å™¨ï¼šå¤±è´¥åé‡è¯•æŒ‡å®šæ¬¡æ•°"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            last_error = None
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    last_error = e
                    print(f"Attempt {attempt + 1} failed: {e}")
                    if attempt < max_attempts - 1:
                        time.sleep(delay)
            raise last_error
        return wrapper
    return decorator

@retry(max_attempts=3, delay=0.5)
def unstable_api_call():
    import random
    if random.random() < 0.7:
        raise Exception("API error")
    return "Success!"
```

**åœ¨ LangChain æºç ä¸­çš„åº”ç”¨ï¼š**

```python
# Pydantic çš„ field_validator
from pydantic import BaseModel, field_validator

class Config(BaseModel):
    temperature: float

    @field_validator('temperature')  # å¸¦å‚æ•°çš„è£…é¥°å™¨
    @classmethod
    def check_temperature(cls, v):
        if not 0 <= v <= 2:
            raise ValueError('temperature must be between 0 and 2')
        return v
```

---

### æ ¸å¿ƒæ¦‚å¿µ3ï¼šç±»è£…é¥°å™¨ ğŸ”§

**ç±»è£…é¥°å™¨æ¥å—ç±»å¹¶è¿”å›ç±»ï¼ˆæˆ–ä¿®æ”¹ç±»ï¼‰**

```python
def singleton(cls):
    """å•ä¾‹è£…é¥°å™¨ï¼šç¡®ä¿ç±»åªæœ‰ä¸€ä¸ªå®ä¾‹"""
    instances = {}

    @functools.wraps(cls)
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class Database:
    def __init__(self):
        print("Creating database connection")

# åªåˆ›å»ºä¸€æ¬¡
db1 = Database()
db2 = Database()
print(db1 is db2)  # True
```

**ç”¨ç±»å®ç°è£…é¥°å™¨ï¼š**

```python
class CountCalls:
    """è®¡æ•°è£…é¥°å™¨ï¼šè®°å½•å‡½æ•°è¢«è°ƒç”¨çš„æ¬¡æ•°"""

    def __init__(self, func):
        self.func = func
        self.count = 0
        functools.update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"{self.func.__name__} è¢«è°ƒç”¨äº† {self.count} æ¬¡")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello():
    print("Hello!")

say_hello()  # say_hello è¢«è°ƒç”¨äº† 1 æ¬¡
say_hello()  # say_hello è¢«è°ƒç”¨äº† 2 æ¬¡
print(say_hello.count)  # 2
```

**åœ¨ LangChain æºç ä¸­çš„åº”ç”¨ï¼š**

```python
# dataclass è£…é¥°å™¨
from dataclasses import dataclass

@dataclass
class Message:
    role: str
    content: str

# ç­‰ä»·äºè‡ªåŠ¨ç”Ÿæˆ __init__, __repr__, __eq__ ç­‰æ–¹æ³•
```

---

### æ‰©å±•æ¦‚å¿µ4ï¼š@property å±æ€§è£…é¥°å™¨ ğŸ“‹

```python
class Circle:
    def __init__(self, radius: float):
        self._radius = radius

    @property
    def radius(self) -> float:
        """è·å–åŠå¾„ï¼ˆgetterï¼‰"""
        return self._radius

    @radius.setter
    def radius(self, value: float) -> None:
        """è®¾ç½®åŠå¾„ï¼ˆsetterï¼‰"""
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value

    @property
    def area(self) -> float:
        """è®¡ç®—å±æ€§ï¼ˆåªè¯»ï¼‰"""
        import math
        return math.pi * self._radius ** 2

circle = Circle(5)
print(circle.radius)  # 5ï¼ˆåƒå±æ€§ä¸€æ ·è®¿é—®ï¼‰
circle.radius = 10    # ä½¿ç”¨ setter
print(circle.area)    # 314.159...ï¼ˆè®¡ç®—å±æ€§ï¼‰
```

**åœ¨ LangChain æºç ä¸­çš„åº”ç”¨ï¼š**

```python
# langchain_core/runnables/base.py
class Runnable:
    @property
    def InputType(self) -> type:
        """è·å–è¾“å…¥ç±»å‹"""
        return get_input_type(self)

    @property
    def OutputType(self) -> type:
        """è·å–è¾“å‡ºç±»å‹"""
        return get_output_type(self)
```

---

### æ‰©å±•æ¦‚å¿µ5ï¼š@classmethod å’Œ @staticmethod ğŸ“

```python
class DateUtils:
    date_format = "%Y-%m-%d"

    def __init__(self, date_str: str):
        from datetime import datetime
        self.date = datetime.strptime(date_str, self.date_format)

    @classmethod
    def from_timestamp(cls, timestamp: float) -> 'DateUtils':
        """ç±»æ–¹æ³•ï¼šå¦ä¸€ç§åˆ›å»ºå®ä¾‹çš„æ–¹å¼"""
        from datetime import datetime
        date_str = datetime.fromtimestamp(timestamp).strftime(cls.date_format)
        return cls(date_str)

    @staticmethod
    def is_valid_format(date_str: str) -> bool:
        """é™æ€æ–¹æ³•ï¼šä¸éœ€è¦è®¿é—®å®ä¾‹æˆ–ç±»"""
        from datetime import datetime
        try:
            datetime.strptime(date_str, "%Y-%m-%d")
            return True
        except ValueError:
            return False

# ä½¿ç”¨
d1 = DateUtils("2024-01-15")
d2 = DateUtils.from_timestamp(1705315200)  # classmethod
valid = DateUtils.is_valid_format("2024-01-15")  # staticmethod
```

**åŒºåˆ«ï¼š**

| è£…é¥°å™¨ | ç¬¬ä¸€ä¸ªå‚æ•° | ç”¨é€” |
|-------|----------|------|
| æ™®é€šæ–¹æ³• | `self`ï¼ˆå®ä¾‹ï¼‰| æ“ä½œå®ä¾‹æ•°æ® |
| `@classmethod` | `cls`ï¼ˆç±»ï¼‰| å·¥å‚æ–¹æ³•ã€æ“ä½œç±»å±æ€§ |
| `@staticmethod` | æ—  | å·¥å…·å‡½æ•°ï¼Œä¸éœ€è¦å®ä¾‹/ç±» |

---

### æ‰©å±•æ¦‚å¿µ6ï¼šå…ƒç±» Metaclass ğŸ”®

```python
class SingletonMeta(type):
    """å•ä¾‹å…ƒç±»"""
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=SingletonMeta):
    def __init__(self):
        print("Creating database")

db1 = Database()
db2 = Database()
print(db1 is db2)  # True
```

**å…ƒç±»çš„å·¥ä½œåŸç†ï¼š**

```python
class MyMeta(type):
    def __new__(mcs, name, bases, namespace):
        """åˆ›å»ºç±»å¯¹è±¡ä¹‹å‰è°ƒç”¨"""
        print(f"Creating class: {name}")
        # å¯ä»¥ä¿®æ”¹ç±»çš„å±æ€§
        namespace['created_by'] = 'MyMeta'
        return super().__new__(mcs, name, bases, namespace)

    def __init__(cls, name, bases, namespace):
        """åˆ›å»ºç±»å¯¹è±¡ä¹‹åè°ƒç”¨"""
        print(f"Initializing class: {name}")
        super().__init__(name, bases, namespace)

    def __call__(cls, *args, **kwargs):
        """åˆ›å»ºå®ä¾‹æ—¶è°ƒç”¨"""
        print(f"Creating instance of: {cls.__name__}")
        return super().__call__(*args, **kwargs)

class MyClass(metaclass=MyMeta):
    pass

obj = MyClass()
print(MyClass.created_by)  # 'MyMeta'
```

**å…ƒç±» vs è£…é¥°å™¨ï¼š**

| ç‰¹æ€§ | ç±»è£…é¥°å™¨ | å…ƒç±» |
|-----|---------|------|
| æ—¶æœº | ç±»åˆ›å»ºå | ç±»åˆ›å»ºæ—¶ |
| ç»§æ‰¿ | ä¸è‡ªåŠ¨ç»§æ‰¿ | è‡ªåŠ¨ç»§æ‰¿ç»™å­ç±» |
| å¤æ‚åº¦ | ç®€å• | å¤æ‚ |
| ç”¨é€” | ä¿®æ”¹ç°æœ‰ç±» | æ§åˆ¶ç±»çš„åˆ›å»º |

---

### æ‰©å±•æ¦‚å¿µ7ï¼šABC æŠ½è±¡åŸºç±» ğŸ­

```python
from abc import ABC, abstractmethod

class Runnable(ABC):
    """æŠ½è±¡åŸºç±»ï¼šå®šä¹‰æ¥å£è§„èŒƒ"""

    @abstractmethod
    def invoke(self, input):
        """å­ç±»å¿…é¡»å®ç°"""
        pass

    @abstractmethod
    async def ainvoke(self, input):
        """å­ç±»å¿…é¡»å®ç°"""
        pass

    def batch(self, inputs):
        """é»˜è®¤å®ç°ï¼ˆå¯é€‰è¦†ç›–ï¼‰"""
        return [self.invoke(inp) for inp in inputs]

# ä¸èƒ½ç›´æ¥å®ä¾‹åŒ–æŠ½è±¡ç±»
# Runnable()  # TypeError: Can't instantiate abstract class

class ChatModel(Runnable):
    def invoke(self, input):
        return f"Response to: {input}"

    async def ainvoke(self, input):
        return f"Async response to: {input}"

# å¯ä»¥å®ä¾‹åŒ–å…·ä½“ç±»
model = ChatModel()
```

**åœ¨ LangChain æºç ä¸­çš„åº”ç”¨ï¼š**

```python
# langchain_core/runnables/base.py
class Runnable(Generic[Input, Output], ABC):
    @abstractmethod
    def invoke(self, input: Input, config: Optional[RunnableConfig] = None) -> Output:
        ...
```

---

## 4. ã€æœ€å°å¯ç”¨ã€‘

æŒæ¡ä»¥ä¸‹å†…å®¹ï¼Œå°±èƒ½å¼€å§‹é˜…è¯» LangChain æºç ï¼š

### 4.1 åŸºç¡€è£…é¥°å™¨

```python
import functools

def my_decorator(func):
    @functools.wraps(func)  # ä¿ç•™å…ƒä¿¡æ¯
    def wrapper(*args, **kwargs):
        # å‰ç½®/åç½®å¤„ç†
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def my_func():
    pass
```

### 4.2 å¸¦å‚æ•°çš„è£…é¥°å™¨

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(times=3)
def say_hi():
    print("Hi!")
```

### 4.3 @property

```python
class MyClass:
    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        self._name = value
```

### 4.4 @classmethod å’Œ @staticmethod

```python
class MyClass:
    @classmethod
    def create(cls, data):  # cls æ˜¯ç±»æœ¬èº«
        return cls(data)

    @staticmethod
    def validate(data):  # æ²¡æœ‰ self/cls
        return bool(data)
```

### 4.5 @abstractmethod

```python
from abc import ABC, abstractmethod

class BaseClass(ABC):
    @abstractmethod
    def must_implement(self):
        """å­ç±»å¿…é¡»å®ç°"""
        pass
```

**è¿™äº›çŸ¥è¯†è¶³ä»¥ï¼š**
- é˜…è¯» LangChain æºç ä¸­çš„è£…é¥°å™¨ç”¨æ³•
- ç†è§£ `@abstractmethod` å®šä¹‰çš„æ¥å£
- ç†è§£ `@property` å®ç°çš„å±æ€§è®¿é—®
- ä½¿ç”¨ Pydantic çš„ `@field_validator`

---

## 5. ã€1ä¸ªç±»æ¯”ã€‘ï¼ˆåŒè½¨åˆ¶ï¼‰

### ç±»æ¯”1ï¼šè£…é¥°å™¨

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šé«˜é˜¶ç»„ä»¶ï¼ˆHOCï¼‰

Python è£…é¥°å™¨å°±åƒ React çš„é«˜é˜¶ç»„ä»¶ï¼ˆHOCï¼‰ã€‚

```javascript
// React HOC: åŒ…è£…ç»„ä»¶ï¼Œæ·»åŠ åŠŸèƒ½
function withLogger(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log('Rendering:', WrappedComponent.name);
    return <WrappedComponent {...props} />;
  };
}

const EnhancedButton = withLogger(Button);
```

```python
# Python è£…é¥°å™¨: åŒ…è£…å‡½æ•°ï¼Œæ·»åŠ åŠŸèƒ½
def with_logger(func):
    def wrapper(*args, **kwargs):
        print(f'Calling: {func.__name__}')
        return func(*args, **kwargs)
    return wrapper

@with_logger
def button_click():
    pass
```

**å¯¹åº”å…³ç³»ï¼š**

| React HOC | Python è£…é¥°å™¨ |
|-----------|-------------|
| `withAuth(Component)` | `@require_auth` |
| `withRouter(Component)` | `@route('/api')` |
| `memo(Component)` | `@lru_cache` |

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šç¤¼ç‰©åŒ…è£…

è£…é¥°å™¨å°±åƒç»™ç¤¼ç‰©åŒ…è£…ï¼š

- **åŸå§‹ç¤¼ç‰©ï¼ˆå‡½æ•°ï¼‰**ï¼šä¸€ä¸ªç©å…·
- **åŒ…è£…ï¼ˆè£…é¥°å™¨ï¼‰**ï¼š
  - åŠ ä¸€ä¸ªæ¼‚äº®çš„ç›’å­
  - è´´ä¸Šè´è¶ç»“
  - å†™ä¸Šç¥ç¦å¡

ç¤¼ç‰©è¿˜æ˜¯é‚£ä¸ªç¤¼ç‰©ï¼Œä½†å˜å¾—æ›´æ¼‚äº®äº†ï¼

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
@åŒ…è£…ç›’
@è´è¶ç»“
@ç¥ç¦å¡
def ç©å…·():
    return "ä¸€ä¸ªå°æ±½è½¦"

é€å‡ºçš„æ—¶å€™ï¼š
1. å…ˆæ”¾è¿›åŒ…è£…ç›’
2. å†è´´è´è¶ç»“
3. æœ€åå†™ç¥ç¦å¡
æ‹†å¼€åè¿˜æ˜¯å°æ±½è½¦ï¼
```

---

### ç±»æ¯”2ï¼šå¸¦å‚æ•°çš„è£…é¥°å™¨

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šå¯é…ç½®çš„ HOC

```javascript
// React: å¯é…ç½®çš„ HOC
function withTheme(theme) {
  return function(WrappedComponent) {
    return function(props) {
      return <WrappedComponent theme={theme} {...props} />;
    };
  };
}

const DarkButton = withTheme('dark')(Button);
```

```python
# Python: å¸¦å‚æ•°çš„è£…é¥°å™¨
def with_theme(theme):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, theme=theme, **kwargs)
        return wrapper
    return decorator

@with_theme('dark')
def render_button():
    pass
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šé€‰æ‹©åŒ…è£…é£æ ¼

å¸¦å‚æ•°çš„è£…é¥°å™¨å°±åƒé€‰æ‹©ç¤¼ç‰©åŒ…è£…é£æ ¼ï¼š

- `@åŒ…è£…(é£æ ¼="åœ£è¯")` â†’ çº¢ç»¿é…è‰²ï¼Œåœ£è¯æ ‘å›¾æ¡ˆ
- `@åŒ…è£…(é£æ ¼="ç”Ÿæ—¥")` â†’ å½©è‰²æ°”çƒï¼Œç”Ÿæ—¥è›‹ç³•å›¾æ¡ˆ
- `@åŒ…è£…(é£æ ¼="ç®€çº¦")` â†’ çº¯è‰²ï¼Œä¸€ä¸ªå°è´è¶ç»“

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
ä½ å»ç¤¼å“åº—ï¼š
1. å…ˆé€‰é£æ ¼ï¼š"è¯·ç”¨åœ£è¯é£æ ¼"ï¼ˆè°ƒç”¨å·¥å‚ï¼‰
2. åº—å‘˜å‡†å¤‡å¥½åœ£è¯é£æ ¼çš„åŒ…è£…ï¼ˆè¿”å›è£…é¥°å™¨ï¼‰
3. æŠŠç¤¼ç‰©äº¤ç»™åº—å‘˜åŒ…è£…ï¼ˆåº”ç”¨è£…é¥°å™¨ï¼‰
4. æ‹¿åˆ°åŒ…è£…å¥½çš„ç¤¼ç‰©ï¼ˆå¾—åˆ°åŒ…è£…åçš„å‡½æ•°ï¼‰
```

---

### ç±»æ¯”3ï¼š@property

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šVue çš„è®¡ç®—å±æ€§ / Getter

```javascript
// Vue computed property
computed: {
  fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
// ä½¿ç”¨ï¼šthis.fullNameï¼ˆä¸æ˜¯ this.fullName()ï¼‰

// JavaScript getter
class Person {
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
// ä½¿ç”¨ï¼šperson.fullName
```

```python
# Python @property
class Person:
    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"

# ä½¿ç”¨ï¼šperson.full_nameï¼ˆä¸æ˜¯ person.full_name()ï¼‰
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šè‡ªåŠ¨è®¡ç®—å™¨

@property å°±åƒä¸€ä¸ªè‡ªåŠ¨è®¡ç®—çš„æ˜¾ç¤ºå™¨ï¼š

- **æ™®é€šå±æ€§**ï¼šä½ å­˜ä»€ä¹ˆï¼Œå®ƒæ˜¾ç¤ºä»€ä¹ˆ
- **property å±æ€§**ï¼šå®ƒè‡ªåŠ¨å¸®ä½ è®¡ç®—æ˜¾ç¤º

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
ä½ çš„ä¹¦åŒ…æœ‰ä¸€ä¸ª"æ€»é‡é‡"æ˜¾ç¤ºå™¨ï¼š
- ä¸ç”¨æ¯æ¬¡åŠ ä¸œè¥¿éƒ½å»ç§¤ä¸Šç§°
- æ˜¾ç¤ºå™¨è‡ªåŠ¨å¸®ä½ åŠ èµ·æ¥
- ä½ åªéœ€è¦çœ‹æ˜¾ç¤ºå™¨å°±çŸ¥é“æ€»é‡é‡

@property
def æ€»é‡é‡(self):
    return self.è¯­æ–‡ä¹¦ + self.æ•°å­¦ä¹¦ + self.æ–‡å…·ç›’
```

---

### ç±»æ¯”4ï¼š@classmethod

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šé™æ€å·¥å‚æ–¹æ³•

```javascript
// JavaScript é™æ€æ–¹æ³•
class User {
  static fromJSON(json) {
    const data = JSON.parse(json);
    return new User(data.name, data.age);
  }
}

const user = User.fromJSON('{"name": "Alice", "age": 25}');
```

```python
# Python @classmethod
class User:
    @classmethod
    def from_json(cls, json_str):
        import json
        data = json.loads(json_str)
        return cls(data['name'], data['age'])

user = User.from_json('{"name": "Alice", "age": 25}')
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šå·¥å‚çš„ä¸åŒç”Ÿäº§çº¿

@classmethod å°±åƒå·¥å‚çš„ä¸åŒè¿›æ–™å£ï¼š

- **æ™®é€šæ–¹å¼**ï¼šä»æ­£é—¨è¿›åŸæ–™ï¼ˆ`__init__`ï¼‰
- **classmethod**ï¼šä»ä¾§é—¨è¿›åŸæ–™ï¼ˆå¦ä¸€ç§åˆ›å»ºæ–¹å¼ï¼‰

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
å†°æ·‡æ·‹å·¥å‚ï¼š
- æ™®é€šæ–¹å¼ï¼šç›´æ¥ç»™é…æ–¹ â†’ åšå‡ºå†°æ·‡æ·‹
- from_frozen()ï¼šç»™å†·å†»æ–™ â†’ å…ˆè§£å†» â†’ åšå‡ºå†°æ·‡æ·‹
- from_powder()ï¼šç»™ç²‰æœ« â†’ å…ˆåŠ æ°´ â†’ åšå‡ºå†°æ·‡æ·‹

ä¸ç®¡ä»å“ªä¸ªé—¨è¿›ï¼Œå‡ºæ¥çš„éƒ½æ˜¯å†°æ·‡æ·‹ï¼
```

---

### ç±»æ¯”5ï¼šå…ƒç±»

#### ğŸ¨ å‰ç«¯è§†è§’ï¼šç±»çš„æ„é€ å‡½æ•° / Proxy

```javascript
// JavaScript æ²¡æœ‰å…ƒç±»ï¼Œä½†å¯ä»¥ç”¨ Proxy ç±»æ¯”
const handler = {
  construct(target, args) {
    console.log(`Creating instance of ${target.name}`);
    return new target(...args);
  }
};

const ProxiedClass = new Proxy(MyClass, handler);
```

```python
# Python å…ƒç±»
class LogMeta(type):
    def __call__(cls, *args, **kwargs):
        print(f"Creating instance of {cls.__name__}")
        return super().__call__(*args, **kwargs)

class MyClass(metaclass=LogMeta):
    pass
```

#### ğŸ§’ å°æœ‹å‹è§†è§’ï¼šåˆ¶é€ æœºå™¨çš„æœºå™¨

å…ƒç±»å°±åƒ"åˆ¶é€ æœºå™¨çš„æœºå™¨"ï¼š

- **æ™®é€šç±»**ï¼šåˆ¶é€ äº§å“çš„æœºå™¨ï¼ˆæ¯”å¦‚åšç©å…·ï¼‰
- **å…ƒç±»**ï¼šåˆ¶é€ æœºå™¨çš„æœºå™¨ï¼ˆåˆ¶é€ åšç©å…·çš„æœºå™¨ï¼‰

**ç”Ÿæ´»ä¾‹å­ï¼š**
```
ç©å…·å‚ï¼š
- ç©å…· = ç©å…·æœºå™¨ åˆ¶é€ å‡ºæ¥çš„
- ç©å…·æœºå™¨ = æœºå™¨å·¥å‚ åˆ¶é€ å‡ºæ¥çš„

ä»£ç ä¸–ç•Œï¼š
- å¯¹è±¡ = ç±» åˆ›å»ºå‡ºæ¥çš„
- ç±» = å…ƒç±» åˆ›å»ºå‡ºæ¥çš„
```

---

### ç±»æ¯”æ€»ç»“è¡¨

| Python æ¦‚å¿µ | JavaScript/React ç±»æ¯” | å°æœ‹å‹ç±»æ¯” |
|------------|---------------------|-----------|
| è£…é¥°å™¨ | HOC é«˜é˜¶ç»„ä»¶ | ç¤¼ç‰©åŒ…è£… |
| å¸¦å‚æ•°è£…é¥°å™¨ | å¯é…ç½® HOC | é€‰æ‹©åŒ…è£…é£æ ¼ |
| `@property` | getter / computed | è‡ªåŠ¨è®¡ç®—æ˜¾ç¤ºå™¨ |
| `@classmethod` | static method | å·¥å‚çš„ä¸åŒè¿›æ–™å£ |
| `@staticmethod` | å·¥å…·å‡½æ•° | ä¸å±äºä»»ä½•äººçš„å·¥å…· |
| å…ƒç±» | Proxy / ç±»æ„é€  | åˆ¶é€ æœºå™¨çš„æœºå™¨ |
| `@abstractmethod` | interface æ–¹æ³• | å¿…é¡»å¡«çš„ç©ºæ ¼ |

---

## 6. ã€åç›´è§‰ç‚¹ã€‘

### è¯¯åŒº1ï¼šè£…é¥°å™¨æ‰§è¡Œé¡ºåºæ˜¯ä»ä¸Šåˆ°ä¸‹ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**
- è£…é¥°å™¨æ˜¯ä»**ä¸‹åˆ°ä¸Š**åº”ç”¨ï¼ˆç¦»å‡½æ•°è¿‘çš„å…ˆåº”ç”¨ï¼‰
- ä½†æ‰§è¡Œæ—¶æ˜¯ä»**ä¸Šåˆ°ä¸‹**ï¼ˆå¤–å±‚å…ˆæ‰§è¡Œï¼‰
- åƒæ´‹è‘±ä¸€æ ·ï¼Œå…ˆåŒ…çš„åœ¨å¤–é¢

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**
å› ä¸ºä»£ç ä»ä¸Šå¾€ä¸‹è¯»ï¼Œç›´è§‰ä»¥ä¸ºä»ä¸Šå¾€ä¸‹æ‰§è¡Œã€‚

**æ­£ç¡®ç†è§£ï¼š**

```python
def decorator_a(func):
    print("Applying A")
    def wrapper(*args, **kwargs):
        print("Before A")
        result = func(*args, **kwargs)
        print("After A")
        return result
    return wrapper

def decorator_b(func):
    print("Applying B")
    def wrapper(*args, **kwargs):
        print("Before B")
        result = func(*args, **kwargs)
        print("After B")
        return result
    return wrapper

@decorator_a
@decorator_b
def greet():
    print("Hello!")

# å®šä¹‰æ—¶è¾“å‡ºï¼ˆä»ä¸‹åˆ°ä¸Šåº”ç”¨ï¼‰ï¼š
# Applying B
# Applying A

greet()
# æ‰§è¡Œæ—¶è¾“å‡ºï¼ˆä»ä¸Šåˆ°ä¸‹æ‰§è¡Œï¼‰ï¼š
# Before A
# Before B
# Hello!
# After B
# After A
```

**ç†è§£æ–¹å¼ï¼š**
```python
# @decorator_a
# @decorator_b
# def greet(): ...

# ç­‰ä»·äº
greet = decorator_a(decorator_b(greet))

# æ‰€ä»¥ï¼š
# 1. å…ˆæ‰§è¡Œ decorator_b(greet)ï¼Œå¾—åˆ° wrapper_b
# 2. å†æ‰§è¡Œ decorator_a(wrapper_b)ï¼Œå¾—åˆ° wrapper_a
# 3. è°ƒç”¨æ—¶å…ˆè¿›å…¥ wrapper_aï¼Œå†è¿›å…¥ wrapper_b
```

---

### è¯¯åŒº2ï¼šfunctools.wraps åªæ˜¯å¥½ä¹ æƒ¯ï¼Œä¸ç”¨ä¹Ÿè¡Œ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**
- æ²¡æœ‰ `@wraps`ï¼Œå‡½æ•°çš„ `__name__`ã€`__doc__` ä¼šä¸¢å¤±
- è°ƒè¯•æ—¶çœ‹ä¸åˆ°åŸå‡½æ•°ä¿¡æ¯
- æŸäº›æ¡†æ¶ä¾èµ–è¿™äº›å…ƒä¿¡æ¯

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**
å› ä¸ºä¸ç”¨ `@wraps` ä»£ç ä¹Ÿèƒ½è¿è¡Œï¼Œçœ‹ä¸å‡ºé—®é¢˜ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```python
# ä¸ç”¨ @wraps
def bad_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@bad_decorator
def greet():
    """é—®å€™å‡½æ•°"""
    return "Hello"

print(greet.__name__)  # "wrapper" âŒ ä¸¢å¤±åŸå
print(greet.__doc__)   # None âŒ ä¸¢å¤±æ–‡æ¡£

# ç”¨ @wraps
import functools

def good_decorator(func):
    @functools.wraps(func)  # ä¿ç•™å…ƒä¿¡æ¯
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@good_decorator
def greet():
    """é—®å€™å‡½æ•°"""
    return "Hello"

print(greet.__name__)  # "greet" âœ…
print(greet.__doc__)   # "é—®å€™å‡½æ•°" âœ…
```

---

### è¯¯åŒº3ï¼šå…ƒç±»å’Œç±»è£…é¥°å™¨åŠŸèƒ½ä¸€æ · âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**
- å…ƒç±»åœ¨**ç±»åˆ›å»ºæ—¶**ä»‹å…¥ï¼Œå¯ä»¥ä¿®æ”¹ç±»çš„å®šä¹‰
- ç±»è£…é¥°å™¨åœ¨**ç±»åˆ›å»ºå**åº”ç”¨ï¼Œåªèƒ½ä¿®æ”¹å·²åˆ›å»ºçš„ç±»
- å…ƒç±»ä¼š**è‡ªåŠ¨ç»§æ‰¿**ç»™å­ç±»ï¼Œè£…é¥°å™¨ä¸ä¼š

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**
å› ä¸ºä¸¤è€…éƒ½èƒ½"ä¿®æ”¹ç±»"ï¼Œçœ‹èµ·æ¥æ•ˆæœç›¸ä¼¼ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```python
# å…ƒç±»ï¼šåˆ›å»ºæ—¶ä»‹å…¥ï¼Œè‡ªåŠ¨ç»§æ‰¿
class MyMeta(type):
    def __new__(mcs, name, bases, namespace):
        namespace['from_meta'] = True
        return super().__new__(mcs, name, bases, namespace)

class Parent(metaclass=MyMeta):
    pass

class Child(Parent):  # è‡ªåŠ¨ç»§æ‰¿å…ƒç±»
    pass

print(Child.from_meta)  # Trueï¼ˆå­ç±»ä¹Ÿæœ‰ï¼‰

# ç±»è£…é¥°å™¨ï¼šåˆ›å»ºååº”ç”¨ï¼Œä¸è‡ªåŠ¨ç»§æ‰¿
def add_attr(cls):
    cls.from_decorator = True
    return cls

@add_attr
class Parent2:
    pass

class Child2(Parent2):  # ä¸ç»§æ‰¿è£…é¥°å™¨
    pass

print(Parent2.from_decorator)  # True
print(hasattr(Child2, 'from_decorator'))  # Falseï¼ˆå­ç±»æ²¡æœ‰ï¼‰
```

---

## 7. ã€å®æˆ˜ä»£ç ã€‘

```python
"""
ç¤ºä¾‹ï¼šä½¿ç”¨è£…é¥°å™¨å’Œå…ƒç±»æ„å»º LangChain é£æ ¼çš„ç»„ä»¶ç³»ç»Ÿ
æ¼”ç¤ºå¸¸è§è£…é¥°å™¨æ¨¡å¼å’Œå®é™…åº”ç”¨
"""

import functools
import time
from typing import Callable, TypeVar, Any, Optional
from abc import ABC, abstractmethod

# ===== 1. åŸºç¡€è£…é¥°å™¨ï¼šæ—¥å¿—å’Œè®¡æ—¶ =====
print("=== 1. åŸºç¡€è£…é¥°å™¨ ===")

def log_call(func: Callable) -> Callable:
    """è®°å½•å‡½æ•°è°ƒç”¨"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"[LOG] Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"[LOG] {func.__name__} returned: {result}")
        return result
    return wrapper

def timer(func: Callable) -> Callable:
    """è®¡æ—¶è£…é¥°å™¨"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        print(f"[TIMER] {func.__name__} took {elapsed:.4f}s")
        return result
    return wrapper

@log_call
@timer
def slow_operation(n: int) -> int:
    """æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ"""
    time.sleep(0.1)
    return n * 2

result = slow_operation(5)

# ===== 2. å¸¦å‚æ•°çš„è£…é¥°å™¨ =====
print("\n=== 2. å¸¦å‚æ•°çš„è£…é¥°å™¨ ===")

def retry(max_attempts: int = 3, exceptions: tuple = (Exception,)):
    """é‡è¯•è£…é¥°å™¨"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            last_error = None
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_error = e
                    print(f"[RETRY] Attempt {attempt + 1} failed: {e}")
            raise last_error
        return wrapper
    return decorator

import random

@retry(max_attempts=3)
def unstable_function():
    """å¯èƒ½å¤±è´¥çš„å‡½æ•°"""
    if random.random() < 0.7:
        raise ValueError("Random failure")
    return "Success!"

try:
    result = unstable_function()
    print(f"Result: {result}")
except ValueError as e:
    print(f"All attempts failed: {e}")

# ===== 3. ç¼“å­˜è£…é¥°å™¨ =====
print("\n=== 3. ç¼“å­˜è£…é¥°å™¨ ===")

def memoize(func: Callable) -> Callable:
    """ç®€å•ç¼“å­˜è£…é¥°å™¨"""
    cache = {}

    @functools.wraps(func)
    def wrapper(*args):
        if args not in cache:
            print(f"[CACHE] Computing {func.__name__}{args}")
            cache[args] = func(*args)
        else:
            print(f"[CACHE] Using cached result for {args}")
        return cache[args]

    wrapper.cache = cache  # æš´éœ²ç¼“å­˜ä¾›è°ƒè¯•
    return wrapper

@memoize
def fibonacci(n: int) -> int:
    """æ–æ³¢é‚£å¥‘æ•°åˆ—"""
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(f"fib(5) = {fibonacci(5)}")
print(f"fib(5) = {fibonacci(5)}")  # ä½¿ç”¨ç¼“å­˜

# ===== 4. @property å®ç° =====
print("\n=== 4. @property ç¤ºä¾‹ ===")

class LLMConfig:
    """LLM é…ç½®ç±»"""

    def __init__(self, model: str = "gpt-4", temperature: float = 0.7):
        self._model = model
        self._temperature = temperature

    @property
    def model(self) -> str:
        """è·å–æ¨¡å‹å"""
        return self._model

    @model.setter
    def model(self, value: str) -> None:
        """è®¾ç½®æ¨¡å‹å"""
        valid_models = ["gpt-4", "gpt-3.5-turbo", "claude-3"]
        if value not in valid_models:
            raise ValueError(f"Invalid model: {value}")
        self._model = value

    @property
    def temperature(self) -> float:
        """è·å–æ¸©åº¦"""
        return self._temperature

    @temperature.setter
    def temperature(self, value: float) -> None:
        """è®¾ç½®æ¸©åº¦"""
        if not 0 <= value <= 2:
            raise ValueError("Temperature must be between 0 and 2")
        self._temperature = value

    @property
    def config_str(self) -> str:
        """åªè¯»å±æ€§ï¼šé…ç½®å­—ç¬¦ä¸²"""
        return f"{self.model}@temp={self.temperature}"

config = LLMConfig()
print(f"Model: {config.model}")
print(f"Config: {config.config_str}")
config.temperature = 0.5
print(f"Updated config: {config.config_str}")

# ===== 5. @classmethod å·¥å‚æ–¹æ³• =====
print("\n=== 5. @classmethod ç¤ºä¾‹ ===")

class Message:
    """æ¶ˆæ¯ç±»"""

    def __init__(self, role: str, content: str):
        self.role = role
        self.content = content

    @classmethod
    def user(cls, content: str) -> 'Message':
        """åˆ›å»ºç”¨æˆ·æ¶ˆæ¯"""
        return cls("user", content)

    @classmethod
    def assistant(cls, content: str) -> 'Message':
        """åˆ›å»ºåŠ©æ‰‹æ¶ˆæ¯"""
        return cls("assistant", content)

    @classmethod
    def system(cls, content: str) -> 'Message':
        """åˆ›å»ºç³»ç»Ÿæ¶ˆæ¯"""
        return cls("system", content)

    @classmethod
    def from_dict(cls, data: dict) -> 'Message':
        """ä»å­—å…¸åˆ›å»º"""
        return cls(data['role'], data['content'])

    def __repr__(self) -> str:
        return f"Message(role={self.role!r}, content={self.content!r})"

# å¤šç§åˆ›å»ºæ–¹å¼
msg1 = Message("user", "Hello")
msg2 = Message.user("Hello")  # classmethod
msg3 = Message.from_dict({"role": "assistant", "content": "Hi!"})

print(msg1)
print(msg2)
print(msg3)

# ===== 6. æŠ½è±¡åŸºç±» =====
print("\n=== 6. æŠ½è±¡åŸºç±»ç¤ºä¾‹ ===")

T = TypeVar('T')

class Runnable(ABC):
    """æŠ½è±¡ Runnable æ¥å£"""

    @abstractmethod
    def invoke(self, input: Any) -> Any:
        """åŒæ­¥è°ƒç”¨ - å¿…é¡»å®ç°"""
        pass

    @property
    @abstractmethod
    def name(self) -> str:
        """åç§° - å¿…é¡»å®ç°"""
        pass

    def batch(self, inputs: list) -> list:
        """æ‰¹é‡å¤„ç† - é»˜è®¤å®ç°"""
        return [self.invoke(inp) for inp in inputs]

class EchoRunnable(Runnable):
    """Echo å®ç°"""

    @property
    def name(self) -> str:
        return "echo"

    def invoke(self, input: Any) -> str:
        return f"Echo: {input}"

echo = EchoRunnable()
print(f"Name: {echo.name}")
print(f"Invoke: {echo.invoke('Hello')}")
print(f"Batch: {echo.batch(['A', 'B', 'C'])}")

# ===== 7. ç±»è£…é¥°å™¨ =====
print("\n=== 7. ç±»è£…é¥°å™¨ç¤ºä¾‹ ===")

def register_component(registry: dict):
    """ç»„ä»¶æ³¨å†Œè£…é¥°å™¨"""
    def decorator(cls):
        registry[cls.__name__] = cls
        return cls
    return decorator

components = {}

@register_component(components)
class ChatModel:
    pass

@register_component(components)
class EmbeddingModel:
    pass

print(f"Registered components: {list(components.keys())}")

# ===== 8. ç”¨ç±»å®ç°è£…é¥°å™¨ =====
print("\n=== 8. ç±»å®ç°è£…é¥°å™¨ ===")

class deprecated:
    """å¼ƒç”¨è­¦å‘Šè£…é¥°å™¨"""

    def __init__(self, reason: str = ""):
        self.reason = reason

    def __call__(self, func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            import warnings
            msg = f"{func.__name__} is deprecated"
            if self.reason:
                msg += f": {self.reason}"
            warnings.warn(msg, DeprecationWarning, stacklevel=2)
            return func(*args, **kwargs)
        return wrapper

@deprecated(reason="Use new_function instead")
def old_function():
    return "old"

import warnings
with warnings.catch_warnings(record=True) as w:
    warnings.simplefilter("always")
    old_function()
    print(f"Warning: {w[0].message}")

# ===== 9. å…ƒç±»ç¤ºä¾‹ =====
print("\n=== 9. å…ƒç±»ç¤ºä¾‹ ===")

class RegistryMeta(type):
    """æ³¨å†Œæ‰€æœ‰å­ç±»çš„å…ƒç±»"""
    _registry = {}

    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        if bases:  # ä¸æ³¨å†ŒåŸºç±»æœ¬èº«
            mcs._registry[name] = cls
        return cls

    @classmethod
    def get_registry(mcs):
        return dict(mcs._registry)

class BaseProcessor(metaclass=RegistryMeta):
    """å¤„ç†å™¨åŸºç±»"""
    pass

class TextProcessor(BaseProcessor):
    pass

class ImageProcessor(BaseProcessor):
    pass

class AudioProcessor(BaseProcessor):
    pass

print(f"Registry: {RegistryMeta.get_registry()}")

# ===== 10. ç»„åˆåº”ç”¨ï¼šLangChain é£æ ¼ç»„ä»¶ =====
print("\n=== 10. ç»„åˆåº”ç”¨ ===")

def validate_input(func: Callable) -> Callable:
    """è¾“å…¥éªŒè¯è£…é¥°å™¨"""
    @functools.wraps(func)
    def wrapper(self, input: Any, *args, **kwargs):
        if input is None:
            raise ValueError("Input cannot be None")
        return func(self, input, *args, **kwargs)
    return wrapper

def trace_call(func: Callable) -> Callable:
    """è°ƒç”¨è¿½è¸ªè£…é¥°å™¨"""
    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        print(f"[TRACE] {self.__class__.__name__}.{func.__name__} called")
        result = func(self, *args, **kwargs)
        print(f"[TRACE] {self.__class__.__name__}.{func.__name__} returned")
        return result
    return wrapper

class LangChainComponent(ABC):
    """LangChain é£æ ¼ç»„ä»¶åŸºç±»"""

    @property
    @abstractmethod
    def name(self) -> str:
        pass

    @abstractmethod
    def invoke(self, input: Any) -> Any:
        pass

class UppercaseTransformer(LangChainComponent):
    """è½¬å¤§å†™ç»„ä»¶"""

    @property
    def name(self) -> str:
        return "uppercase"

    @trace_call
    @validate_input
    def invoke(self, input: str) -> str:
        return input.upper()

transformer = UppercaseTransformer()
print(f"Component: {transformer.name}")
print(f"Result: {transformer.invoke('hello world')}")
```

**è¿è¡Œè¾“å‡ºç¤ºä¾‹ï¼š**
```
=== 1. åŸºç¡€è£…é¥°å™¨ ===
[LOG] Calling slow_operation
[TIMER] slow_operation took 0.1001s
[LOG] slow_operation returned: 10

=== 2. å¸¦å‚æ•°çš„è£…é¥°å™¨ ===
[RETRY] Attempt 1 failed: Random failure
[RETRY] Attempt 2 failed: Random failure
Result: Success!

=== 3. ç¼“å­˜è£…é¥°å™¨ ===
[CACHE] Computing fibonacci(5)
[CACHE] Computing fibonacci(4)
...
fib(5) = 5
[CACHE] Using cached result for (5,)
fib(5) = 5

=== 4. @property ç¤ºä¾‹ ===
Model: gpt-4
Config: gpt-4@temp=0.7
Updated config: gpt-4@temp=0.5

=== 5. @classmethod ç¤ºä¾‹ ===
Message(role='user', content='Hello')
Message(role='user', content='Hello')
Message(role='assistant', content='Hi!')

=== 6. æŠ½è±¡åŸºç±»ç¤ºä¾‹ ===
Name: echo
Invoke: Echo: Hello
Batch: ['Echo: A', 'Echo: B', 'Echo: C']

=== 7. ç±»è£…é¥°å™¨ç¤ºä¾‹ ===
Registered components: ['ChatModel', 'EmbeddingModel']

=== 8. ç±»å®ç°è£…é¥°å™¨ ===
Warning: old_function is deprecated: Use new_function instead

=== 9. å…ƒç±»ç¤ºä¾‹ ===
Registry: {'TextProcessor': <class 'TextProcessor'>, ...}

=== 10. ç»„åˆåº”ç”¨ ===
Component: uppercase
[TRACE] UppercaseTransformer.invoke called
[TRACE] UppercaseTransformer.invoke returned
Result: HELLO WORLD
```

---

## 8. ã€é¢è¯•å¿…é—®ã€‘

### é—®é¢˜ï¼š"Python è£…é¥°å™¨çš„åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**
"è£…é¥°å™¨æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œæ¥å—å‡½æ•°å‚æ•°ï¼Œè¿”å›æ–°å‡½æ•°ã€‚@decorator æ˜¯è¯­æ³•ç³–ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **è£…é¥°å™¨çš„åŸç†åˆ†ä¸‰ä¸ªå±‚é¢ï¼š**
>
> 1. **è¯­æ³•å±‚é¢**ï¼š`@decorator` æ˜¯è¯­æ³•ç³–
> ```python
> @decorator
> def func(): pass
> # ç­‰ä»·äº
> func = decorator(func)
> ```
>
> 2. **å®ç°å±‚é¢**ï¼šè£…é¥°å™¨æ˜¯æ¥å—å¯è°ƒç”¨å¯¹è±¡ã€è¿”å›å¯è°ƒç”¨å¯¹è±¡çš„é«˜é˜¶å‡½æ•°
> ```python
> def decorator(func):
>     def wrapper(*args, **kwargs):
>         # å‰ç½®/åç½®å¤„ç†
>         return func(*args, **kwargs)
>     return wrapper
> ```
>
> 3. **è®¾è®¡å±‚é¢**ï¼šè£…é¥°å™¨å®ç°äº†**å¼€é—­åŸåˆ™**ï¼ˆOpen-Closed Principleï¼‰
>    - å¯¹æ‰©å±•å¼€æ”¾ï¼šå¯ä»¥æ·»åŠ æ–°åŠŸèƒ½
>    - å¯¹ä¿®æ”¹å…³é—­ï¼šä¸éœ€è¦ä¿®æ”¹åŸå‡½æ•°
>
> **é‡è¦ç»†èŠ‚**ï¼š
> - ç”¨ `@functools.wraps` ä¿ç•™åŸå‡½æ•°å…ƒä¿¡æ¯
> - å¤šä¸ªè£…é¥°å™¨ä»ä¸‹åˆ°ä¸Šåº”ç”¨ï¼Œä»ä¸Šåˆ°ä¸‹æ‰§è¡Œ
> - å¸¦å‚æ•°çš„è£…é¥°å™¨æœ¬è´¨æ˜¯"è£…é¥°å™¨å·¥å‚"
>
> **åœ¨ LangChain ä¸­çš„åº”ç”¨**ï¼š`@abstractmethod` å®šä¹‰æ¥å£ã€`@property` å®ç°å±æ€§ã€Pydantic çš„ `@field_validator` å®ç°éªŒè¯ã€‚

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… åˆ†å±‚å›ç­”ï¼Œç”±æµ…å…¥æ·±
2. âœ… ç»™å‡ºäº†ä»£ç ç¤ºä¾‹
3. âœ… æåˆ°äº†è®¾è®¡åŸåˆ™
4. âœ… è”ç³»äº†å®é™…åº”ç”¨

---

### é—®é¢˜ï¼š"ä»€ä¹ˆæ—¶å€™ç”¨å…ƒç±»ï¼Ÿèƒ½ä¸¾ä¸ªä¾‹å­å—ï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**
"å…ƒç±»æ˜¯ç±»çš„ç±»ï¼Œå¯ä»¥æ§åˆ¶ç±»çš„åˆ›å»ºã€‚æ¯”å¦‚ ORM æ¡†æ¶ç”¨å…ƒç±»ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **å…ƒç±»çš„ä½¿ç”¨åœºæ™¯**ï¼šéœ€è¦åœ¨ç±»å®šä¹‰æ—¶ï¼ˆä¸æ˜¯å®ä¾‹åŒ–æ—¶ï¼‰è‡ªåŠ¨åšä¸€äº›äº‹æƒ…ï¼Œç‰¹åˆ«æ˜¯éœ€è¦å½±å“æ‰€æœ‰å­ç±»æ—¶ã€‚
>
> **å…¸å‹ä¾‹å­ï¼šè‡ªåŠ¨æ³¨å†Œæ‰€æœ‰å­ç±»**
> ```python
> class PluginMeta(type):
>     registry = {}
>     def __new__(mcs, name, bases, namespace):
>         cls = super().__new__(mcs, name, bases, namespace)
>         if bases:  # æ’é™¤åŸºç±»
>             mcs.registry[name] = cls
>         return cls
>
> class Plugin(metaclass=PluginMeta):
>     pass
>
> class AudioPlugin(Plugin): pass
> class VideoPlugin(Plugin): pass
>
> # è‡ªåŠ¨æ³¨å†Œ
> print(PluginMeta.registry)  # {'AudioPlugin': ..., 'VideoPlugin': ...}
> ```
>
> **å…ƒç±» vs ç±»è£…é¥°å™¨**ï¼š
> - å…ƒç±»ä¼š**è‡ªåŠ¨ç»§æ‰¿**ç»™å­ç±»
> - ç±»è£…é¥°å™¨åªä½œç”¨äºå½“å‰ç±»
>
> **ä»€ä¹ˆæ—¶å€™ç”¨å…ƒç±»**ï¼š
> - éœ€è¦æ‰€æœ‰å­ç±»éƒ½å…·æœ‰æŸç§è¡Œä¸º
> - éœ€è¦åœ¨ç±»å®šä¹‰æ—¶æ£€æŸ¥æˆ–ä¿®æ”¹ç±»
> - ORM æ¡†æ¶ï¼ˆDjango Modelï¼‰ã€åºåˆ—åŒ–æ¡†æ¶ï¼ˆPydanticï¼‰
>
> **å¤§å¤šæ•°æƒ…å†µç”¨ç±»è£…é¥°å™¨å°±å¤Ÿäº†**ï¼Œå…ƒç±»æ˜¯æœ€åæ‰‹æ®µã€‚

---

## 9. ã€åŒ–éª¨ç»µæŒã€‘

### å¡ç‰‡1ï¼šè£…é¥°å™¨æ˜¯ä»€ä¹ˆï¼Ÿ ğŸ¯

**ä¸€å¥è¯ï¼š** è£…é¥°å™¨æ˜¯æ¥å—å‡½æ•°ã€è¿”å›å‡½æ•°çš„å¯è°ƒç”¨å¯¹è±¡ï¼Œç”¨äºåœ¨ä¸ä¿®æ”¹åŸä»£ç çš„æƒ…å†µä¸‹å¢å¼ºåŠŸèƒ½ã€‚

**ä¸¾ä¾‹ï¼š**
```python
@timer
def slow_func():
    time.sleep(1)
# ç­‰ä»·äº: slow_func = timer(slow_func)
```

**åº”ç”¨ï¼š** LangChain ç”¨è£…é¥°å™¨å®šä¹‰æŠ½è±¡æ–¹æ³•ã€å±æ€§ã€éªŒè¯å™¨ã€‚

---

### å¡ç‰‡2ï¼šè£…é¥°å™¨åŸºæœ¬æ¨¡æ¿ ğŸ“

**ä¸€å¥è¯ï¼š** è£…é¥°å™¨çš„æ ‡å‡†å†™æ³•åŒ…æ‹¬ wrapper å‡½æ•°å’Œ functools.wrapsã€‚

**ä¸¾ä¾‹ï¼š**
```python
import functools

def my_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
```

**åº”ç”¨ï¼š** ç¼–å†™è‡ªå®šä¹‰è£…é¥°å™¨çš„æ ‡å‡†æ¨¡æ¿ã€‚

---

### å¡ç‰‡3ï¼šå¸¦å‚æ•°çš„è£…é¥°å™¨ ğŸ”§

**ä¸€å¥è¯ï¼š** å¸¦å‚æ•°çš„è£…é¥°å™¨æ˜¯è¿”å›è£…é¥°å™¨çš„å‡½æ•°ï¼ˆè£…é¥°å™¨å·¥å‚ï¼‰ã€‚

**ä¸¾ä¾‹ï¼š**
```python
def repeat(times):       # å¤–å±‚ï¼šæ¥æ”¶å‚æ•°
    def decorator(func): # ä¸­å±‚ï¼šæ¥æ”¶å‡½æ•°
        def wrapper():   # å†…å±‚ï¼šåŒ…è£…æ‰§è¡Œ
            for _ in range(times):
                func()
        return wrapper
    return decorator
```

**åº”ç”¨ï¼š** `@retry(max_attempts=3)`, `@cache(ttl=60)`

---

### å¡ç‰‡4ï¼š@property å±æ€§è£…é¥°å™¨ ğŸ 

**ä¸€å¥è¯ï¼š** @property æŠŠæ–¹æ³•å˜æˆå±æ€§ï¼Œå®ç° getter/setterã€‚

**ä¸¾ä¾‹ï¼š**
```python
class Circle:
    @property
    def area(self):
        return 3.14 * self.r ** 2

c.area  # åƒå±æ€§ä¸€æ ·è®¿é—®ï¼Œä¸ç”¨ c.area()
```

**åº”ç”¨ï¼š** LangChain Runnable çš„ InputTypeã€OutputType å±æ€§ã€‚

---

### å¡ç‰‡5ï¼š@classmethod ç±»æ–¹æ³• ğŸ­

**ä¸€å¥è¯ï¼š** @classmethod çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç±»ï¼ˆclsï¼‰ï¼Œå¸¸ç”¨äºå·¥å‚æ–¹æ³•ã€‚

**ä¸¾ä¾‹ï¼š**
```python
class User:
    @classmethod
    def from_json(cls, data):
        return cls(data['name'])

user = User.from_json({"name": "Alice"})
```

**åº”ç”¨ï¼š** LangChain çš„ `Message.from_dict()` ç­‰å·¥å‚æ–¹æ³•ã€‚

---

### å¡ç‰‡6ï¼š@staticmethod é™æ€æ–¹æ³• ğŸ”¨

**ä¸€å¥è¯ï¼š** @staticmethod æ²¡æœ‰ self/clsï¼Œæ˜¯æ”¾åœ¨ç±»é‡Œçš„æ™®é€šå‡½æ•°ã€‚

**ä¸¾ä¾‹ï¼š**
```python
class Math:
    @staticmethod
    def add(a, b):
        return a + b

Math.add(1, 2)  # ä¸éœ€è¦å®ä¾‹
```

**åº”ç”¨ï¼š** å·¥å…·å‡½æ•°ã€ä¸éœ€è¦è®¿é—®å®ä¾‹/ç±»çŠ¶æ€çš„æ–¹æ³•ã€‚

---

### å¡ç‰‡7ï¼š@abstractmethod æŠ½è±¡æ–¹æ³• ğŸ“‹

**ä¸€å¥è¯ï¼š** @abstractmethod æ ‡è®°å¿…é¡»ç”±å­ç±»å®ç°çš„æ–¹æ³•ã€‚

**ä¸¾ä¾‹ï¼š**
```python
from abc import ABC, abstractmethod

class Runnable(ABC):
    @abstractmethod
    def invoke(self, input):
        pass
```

**åº”ç”¨ï¼š** LangChain Runnable åè®®å®šä¹‰çš„æ¥å£æ–¹æ³•ã€‚

---

### å¡ç‰‡8ï¼šè£…é¥°å™¨æ‰§è¡Œé¡ºåº ğŸ”„

**ä¸€å¥è¯ï¼š** å¤šä¸ªè£…é¥°å™¨ä»ä¸‹åˆ°ä¸Šåº”ç”¨ï¼Œä»ä¸Šåˆ°ä¸‹æ‰§è¡Œã€‚

**ä¸¾ä¾‹ï¼š**
```python
@A  # ç¬¬äºŒä¸ªåº”ç”¨ï¼Œç¬¬ä¸€ä¸ªæ‰§è¡Œ
@B  # ç¬¬ä¸€ä¸ªåº”ç”¨ï¼Œç¬¬äºŒä¸ªæ‰§è¡Œ
def func(): ...

# ç­‰ä»·äº: func = A(B(func))
```

**åº”ç”¨ï¼š** ç†è§£è£…é¥°å™¨æ ˆçš„æ‰§è¡Œé¡ºåºã€‚

---

### å¡ç‰‡9ï¼šå…ƒç±»åŸºç¡€ ğŸ”®

**ä¸€å¥è¯ï¼š** å…ƒç±»æ˜¯ç±»çš„ç±»ï¼Œæ§åˆ¶ç±»çš„åˆ›å»ºè¿‡ç¨‹ã€‚

**ä¸¾ä¾‹ï¼š**
```python
class Meta(type):
    def __new__(mcs, name, bases, namespace):
        # ä¿®æ”¹ç±»çš„å®šä¹‰
        return super().__new__(mcs, name, bases, namespace)

class MyClass(metaclass=Meta):
    pass
```

**åº”ç”¨ï¼š** è‡ªåŠ¨æ³¨å†Œç»„ä»¶ã€ORM æ¡†æ¶ã€åºåˆ—åŒ–æ¡†æ¶ã€‚

---

### å¡ç‰‡10ï¼šåœ¨ LangChain æºç ä¸­çš„åº”ç”¨ â­

**ä¸€å¥è¯ï¼š** LangChain ç”¨ @abstractmethod å®šä¹‰æ¥å£ã€@property å®šä¹‰å±æ€§ã€è£…é¥°å™¨å®ç°éªŒè¯å’Œç¼“å­˜ã€‚

**ä¸¾ä¾‹ï¼š**
```python
# langchain_core/runnables/base.py
class Runnable(ABC):
    @abstractmethod
    def invoke(self, input): ...

    @property
    def InputType(self): ...
```

**åº”ç”¨ï¼š** ç†è§£è¿™äº›è£…é¥°å™¨å°±èƒ½è¯»æ‡‚ LangChain çš„æ¶æ„è®¾è®¡ã€‚

---

## 10. ã€ä¸€å¥è¯æ€»ç»“ã€‘

**è£…é¥°å™¨æ˜¯ Python çš„é«˜é˜¶å‡½æ•°è¯­æ³•ç³–ï¼Œé€šè¿‡åŒ…è£…å‡½æ•°æ¥å¢å¼ºåŠŸèƒ½è€Œä¸ä¿®æ”¹åŸä»£ç ï¼›å…ƒç±»æ˜¯ç±»çš„ç±»ï¼Œæ§åˆ¶ç±»çš„åˆ›å»ºè¿‡ç¨‹ï¼›ä¸¤è€…æ˜¯ LangChain å®ç°æŠ½è±¡æ¥å£ã€å±æ€§è®¿é—®ã€éªŒè¯é€»è¾‘çš„åŸºç¡€æœºåˆ¶ã€‚**

---

## ğŸ“š å­¦ä¹ æ£€æŸ¥æ¸…å•

- [ ] ç†è§£è£…é¥°å™¨æ˜¯é«˜é˜¶å‡½æ•°
- [ ] ä¼šå†™åŸºç¡€è£…é¥°å™¨ï¼ˆå¸¦ functools.wrapsï¼‰
- [ ] ä¼šå†™å¸¦å‚æ•°çš„è£…é¥°å™¨
- [ ] ç†è§£ @property çš„ getter/setter
- [ ] ç†è§£ @classmethod å’Œ @staticmethod çš„åŒºåˆ«
- [ ] ç†è§£ @abstractmethod å®šä¹‰æ¥å£
- [ ] çŸ¥é“è£…é¥°å™¨çš„æ‰§è¡Œé¡ºåº
- [ ] äº†è§£å…ƒç±»çš„åŸºæœ¬æ¦‚å¿µ

## ğŸ”— ä¸‹ä¸€æ­¥å­¦ä¹ 

- **ä¸Šä¸‹æ–‡ç®¡ç†å™¨**ï¼šwith è¯­å¥å’Œèµ„æºç®¡ç†
- **Runnable åè®®**ï¼šLangChain çš„æ ¸å¿ƒæŠ½è±¡
- **Pydantic æ•°æ®éªŒè¯**ï¼šfield_validator è£…é¥°å™¨

---

**ç‰ˆæœ¬ï¼š** v1.0
**æœ€åæ›´æ–°ï¼š** 2025-01-14
