# 类型提示与泛型 (Type Hints)

> 原子化知识点 | Python高级特性 | LangChain 源码学习前置知识

---

## 1. 【30字核心】

**类型提示是 Python 的静态类型注解系统，泛型让代码可以处理多种类型，是 LangChain Runnable 协议的基石。**

---

## 2. 【第一性原理】

### 什么是第一性原理？

**第一性原理**：回到事物最基本的真理，从源头思考问题

### 类型提示的第一性原理 🎯

#### 1. 最基础的定义

**类型提示 = 给变量贴标签，告诉大家这里应该放什么类型的数据**

仅此而已！没有更基础的了。

- **类型注解**：`name: str` 表示 name 应该是字符串
- **返回值注解**：`-> int` 表示函数返回整数
- **泛型**：`List[str]` 表示字符串列表

#### 2. 为什么需要类型提示？

**核心问题：Python 是动态类型语言，运行时不检查类型，大型项目容易出错**

```python
# Python 动态类型：运行时才发现错误
def add(a, b):
    return a + b

add(1, 2)       # 3 ✅
add("1", "2")   # "12" ✅
add(1, "2")     # TypeError! 运行时才报错 ❌
```

问题：
- 代码意图不清晰（这个函数接受什么？）
- IDE 无法提供智能补全
- 错误要到运行时才能发现
- 大型项目难以维护

#### 3. 类型提示的三层价值

##### 价值1：代码即文档

```python
# 没有类型提示：猜测参数类型
def process_messages(messages, config):
    pass

# 有类型提示：一目了然
def process_messages(
    messages: List[Message],
    config: Optional[RunnableConfig] = None
) -> List[str]:
    pass
```

##### 价值2：IDE 智能支持

```python
from typing import List

def get_names(users: List[User]) -> List[str]:
    return [u.name for u in users]
    #        ↑ IDE 自动补全 User 的属性
```

##### 价值3：静态检查（提前发现错误）

```python
# mypy / pyright 可以在运行前发现问题
def greet(name: str) -> str:
    return f"Hello, {name}"

greet(123)  # mypy 报错：Argument 1 has incompatible type "int"; expected "str"
```

#### 4. 从第一性原理推导 LangChain 源码应用

**推理链：**

```
1. LangChain 需要处理多种类型的输入输出（文本、消息、字典等）
   ↓
2. 组件之间需要类型安全的数据传递
   ↓
3. Runnable 是通用组件抽象，需要支持任意输入输出类型
   ↓
4. Python 的泛型（Generic）可以参数化类型
   ↓
5. 定义 Runnable[Input, Output] 泛型类
   ↓
6. 每个具体 Runnable 指定自己的 Input/Output 类型
   ↓
7. 类型检查器可以验证 Chain 组合的类型兼容性
```

#### 5. 一句话总结第一性原理

**类型提示是给 Python 代码添加"类型标签"，让代码更清晰、IDE 更智能、错误更早发现，泛型让这套系统能处理任意类型。**

---

## 3. 【核心概念（全面覆盖）】

### 核心概念1：基础类型注解 🏷️

**类型注解是给变量和函数添加类型信息的语法**

```python
from typing import List, Dict, Optional, Union, Any

# ===== 变量注解 =====
name: str = "Alice"
age: int = 25
score: float = 95.5
is_active: bool = True

# ===== 函数注解 =====
def greet(name: str) -> str:
    return f"Hello, {name}"

# ===== 复合类型 =====
names: List[str] = ["Alice", "Bob"]
scores: Dict[str, int] = {"Alice": 95, "Bob": 87}
config: Optional[dict] = None  # 可以是 dict 或 None

# ===== Union 联合类型 =====
user_id: Union[int, str] = 123  # 可以是 int 或 str
user_id = "user_123"  # 也可以

# ===== Any 任意类型 =====
data: Any = {"key": "value"}  # 任意类型，放弃类型检查
```

**Python 3.9+ 简化语法：**

```python
# Python 3.9+ 可以直接用内置类型
names: list[str] = ["Alice", "Bob"]
scores: dict[str, int] = {"Alice": 95}
config: dict | None = None  # Python 3.10+ Union 语法
```

**在 LangChain 源码中的应用：**

```python
# langchain_core/messages/base.py
class BaseMessage(BaseModel):
    content: Union[str, List[Union[str, Dict]]]  # 内容可以是字符串或列表
    additional_kwargs: dict = Field(default_factory=dict)
    type: str
    name: Optional[str] = None
    id: Optional[str] = None
```

---

### 核心概念2：TypeVar 类型变量 📐

**TypeVar 定义一个"类型占位符"，让函数/类能处理多种类型**

```python
from typing import TypeVar, List

# 定义类型变量
T = TypeVar('T')  # T 可以是任何类型

# 使用类型变量：输入什么类型，输出就是什么类型
def first(items: List[T]) -> T:
    return items[0]

# 调用时类型自动推导
result1 = first([1, 2, 3])      # result1: int
result2 = first(["a", "b"])     # result2: str
result3 = first([1.0, 2.0])     # result3: float
```

**带约束的 TypeVar：**

```python
from typing import TypeVar

# 约束 T 只能是 str 或 bytes
T = TypeVar('T', str, bytes)

def concat(a: T, b: T) -> T:
    return a + b

concat("hello", " world")  # ✅ str
concat(b"hello", b" world")  # ✅ bytes
concat(1, 2)  # ❌ mypy 报错：int 不在约束范围内
```

**bound 约束（必须是某类型的子类）：**

```python
from typing import TypeVar

class Animal:
    def speak(self) -> str:
        return "..."

class Dog(Animal):
    def speak(self) -> str:
        return "Woof!"

# T 必须是 Animal 或其子类
T = TypeVar('T', bound=Animal)

def make_speak(animal: T) -> str:
    return animal.speak()

make_speak(Dog())  # ✅
make_speak("not an animal")  # ❌ mypy 报错
```

**在 LangChain 源码中的应用：**

```python
# langchain_core/runnables/base.py
Input = TypeVar("Input", contravariant=True)  # 输入类型（逆变）
Output = TypeVar("Output", covariant=True)    # 输出类型（协变）

# Runnable 使用这两个类型变量
class Runnable(Generic[Input, Output], ABC):
    @abstractmethod
    def invoke(self, input: Input, config: Optional[RunnableConfig] = None) -> Output:
        ...
```

---

### 核心概念3：Generic 泛型类 🔧

**Generic 让类可以参数化类型，创建可复用的类型安全容器**

```python
from typing import TypeVar, Generic, Optional

T = TypeVar('T')

class Box(Generic[T]):
    """一个可以装任何类型的盒子"""

    def __init__(self, content: T) -> None:
        self._content = content

    def get(self) -> T:
        return self._content

    def set(self, content: T) -> None:
        self._content = content

# 使用泛型类
int_box: Box[int] = Box(42)
str_box: Box[str] = Box("hello")

value1: int = int_box.get()  # 类型推导为 int
value2: str = str_box.get()  # 类型推导为 str

int_box.set("wrong")  # ❌ mypy 报错：期望 int，得到 str
```

**多类型参数的泛型：**

```python
from typing import TypeVar, Generic

K = TypeVar('K')
V = TypeVar('V')

class Pair(Generic[K, V]):
    """键值对"""
    def __init__(self, key: K, value: V) -> None:
        self.key = key
        self.value = value

# 使用
pair1: Pair[str, int] = Pair("age", 25)
pair2: Pair[int, str] = Pair(1, "first")
```

**在 LangChain 源码中的应用：**

```python
# langchain_core/runnables/base.py 简化版
from typing import TypeVar, Generic
from abc import ABC, abstractmethod

Input = TypeVar("Input")
Output = TypeVar("Output")

class Runnable(Generic[Input, Output], ABC):
    """LangChain 最核心的泛型抽象"""

    @abstractmethod
    def invoke(self, input: Input, config: Optional[RunnableConfig] = None) -> Output:
        """同步调用"""
        ...

    @abstractmethod
    async def ainvoke(self, input: Input, config: Optional[RunnableConfig] = None) -> Output:
        """异步调用"""
        ...

# 具体实现指定类型
class ChatModel(Runnable[List[BaseMessage], AIMessage]):
    """聊天模型：输入消息列表，输出 AI 消息"""

    def invoke(self, input: List[BaseMessage], config: Optional[RunnableConfig] = None) -> AIMessage:
        # 实现聊天逻辑
        ...

class StrOutputParser(Runnable[AIMessage, str]):
    """输出解析器：输入 AI 消息，输出字符串"""

    def invoke(self, input: AIMessage, config: Optional[RunnableConfig] = None) -> str:
        return input.content
```

---

### 扩展概念4：Protocol 协议（结构化子类型） 📋

```python
from typing import Protocol, runtime_checkable

# 定义协议（接口）
@runtime_checkable
class Drawable(Protocol):
    def draw(self) -> str:
        ...

# 不需要显式继承，只要有 draw 方法就符合协议
class Circle:
    def draw(self) -> str:
        return "○"

class Square:
    def draw(self) -> str:
        return "□"

def render(shape: Drawable) -> str:
    return shape.draw()

# 都可以传入，因为都有 draw 方法
render(Circle())  # ✅
render(Square())  # ✅

# runtime_checkable 允许运行时检查
print(isinstance(Circle(), Drawable))  # True
```

**在 LangChain 源码中的应用：**

```python
# Runnable 实际上就是一个 Protocol
# 任何实现了 invoke/ainvoke/batch/stream 的类都是 Runnable
```

---

### 扩展概念5：Callable 可调用类型 📞

```python
from typing import Callable

# Callable[[参数类型列表], 返回类型]
def apply(func: Callable[[int, int], int], a: int, b: int) -> int:
    return func(a, b)

def add(x: int, y: int) -> int:
    return x + y

result = apply(add, 1, 2)  # 3
```

**在 LangChain 源码中的应用：**

```python
# langchain_core/runnables/base.py
from typing import Callable

class RunnableLambda(Runnable[Input, Output]):
    """将普通函数包装成 Runnable"""

    def __init__(self, func: Callable[[Input], Output]) -> None:
        self.func = func

    def invoke(self, input: Input, config: Optional[RunnableConfig] = None) -> Output:
        return self.func(input)
```

---

### 扩展概念6：Literal 字面量类型 🎯

```python
from typing import Literal

# 只能是这几个字面值之一
def set_mode(mode: Literal["read", "write", "append"]) -> None:
    print(f"Mode: {mode}")

set_mode("read")    # ✅
set_mode("write")   # ✅
set_mode("delete")  # ❌ mypy 报错
```

**在 LangChain 源码中的应用：**

```python
# 消息类型只能是特定值
class BaseMessage(BaseModel):
    type: Literal["human", "ai", "system", "function", "tool"]
```

---

### 扩展概念7：TypedDict 类型化字典 📖

```python
from typing import TypedDict, Required, NotRequired

class MovieTypedDict(TypedDict):
    title: str
    year: int
    rating: NotRequired[float]  # 可选

# 使用
movie: MovieTypedDict = {
    "title": "Inception",
    "year": 2010
}

movie["title"]  # IDE 知道这是 str
movie["foo"]    # ❌ mypy 报错：foo 不是有效的键
```

**在 LangChain 源码中的应用：**

```python
# langchain_core/runnables/config.py
class RunnableConfig(TypedDict, total=False):
    tags: List[str]
    metadata: Dict[str, Any]
    callbacks: Callbacks
    max_concurrency: Optional[int]
    recursion_limit: int
```

---

## 4. 【最小可用】

掌握以下内容，就能开始进行 LangChain 源码阅读：

### 4.1 基础类型注解

```python
from typing import List, Dict, Optional, Union, Any

# 基本类型
name: str = "Alice"
count: int = 10

# 容器类型
items: List[str] = ["a", "b"]
mapping: Dict[str, int] = {"a": 1}

# 可选（可能是 None）
config: Optional[dict] = None

# 联合类型（多选一）
value: Union[str, int] = "hello"  # 或 123
```

### 4.2 函数类型注解

```python
def process(
    text: str,                    # 必填参数
    max_length: int = 100,        # 带默认值
    config: Optional[dict] = None # 可选参数
) -> str:                         # 返回类型
    return text[:max_length]
```

### 4.3 TypeVar 和 Generic

```python
from typing import TypeVar, Generic

T = TypeVar('T')

class Container(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

    def get(self) -> T:
        return self.value

# 使用
box: Container[str] = Container("hello")
```

### 4.4 理解 Runnable 的类型签名

```python
# LangChain 源码中的常见模式
Input = TypeVar("Input")
Output = TypeVar("Output")

class Runnable(Generic[Input, Output]):
    def invoke(self, input: Input) -> Output:
        ...

# 阅读时的理解方式：
# Runnable[str, int] 表示：输入 str，输出 int
# Runnable[List[Message], AIMessage] 表示：输入消息列表，输出 AI 消息
```

### 4.5 Python 3.10+ 简化语法

```python
# Python 3.10+ 推荐写法
def process(text: str | None = None) -> list[str]:
    if text is None:
        return []
    return text.split()
```

**这些知识足以：**
- 阅读 LangChain 源码中的类型注解
- 理解 Runnable[Input, Output] 的含义
- 编写类型安全的 LangChain 应用
- 使用 IDE 的智能补全功能

---

## 5. 【1个类比】（双轨制）

### 类比1：TypeVar 类型变量

#### 🎨 前端视角：TypeScript 泛型参数

TypeVar 就像 TypeScript 中的泛型参数 `<T>`。

```typescript
// TypeScript: 泛型函数
function first<T>(items: T[]): T {
  return items[0];
}

const num: number = first([1, 2, 3]);  // T 被推导为 number
const str: string = first(["a", "b"]); // T 被推导为 string
```

```python
# Python: TypeVar 达到相同效果
from typing import TypeVar, List

T = TypeVar('T')

def first(items: List[T]) -> T:
    return items[0]

num: int = first([1, 2, 3])    # T 被推导为 int
text: str = first(["a", "b"]) # T 被推导为 str
```

**关键区别：** TypeScript 在函数定义处声明 `<T>`，Python 需要先用 `TypeVar` 定义

#### 🧒 小朋友视角：万能模具

TypeVar 就像一个万能模具：

- **普通模具**：做饼干的模具只能做饼干形状
- **万能模具（TypeVar）**：可以变成任何形状
  - 放进苹果 → 出来苹果形状
  - 放进星星 → 出来星星形状
  - 放进什么 → 出来就是什么

**生活例子：**
```
你有一个神奇的复印机（TypeVar T）：
- 放进一张红纸 → 复印出红纸
- 放进一张蓝纸 → 复印出蓝纸
- 放进什么颜色 → 出来就是什么颜色

这比普通复印机（只能出白纸）厉害多了！
```

---

### 类比2：Generic 泛型类

#### 🎨 前端视角：TypeScript 泛型类/接口

```typescript
// TypeScript: 泛型接口
interface Box<T> {
  content: T;
  get(): T;
}

// 具体化类型
const numBox: Box<number> = { content: 42, get: () => 42 };
const strBox: Box<string> = { content: "hi", get: () => "hi" };
```

```python
# Python: Generic 泛型类
from typing import TypeVar, Generic

T = TypeVar('T')

class Box(Generic[T]):
    def __init__(self, content: T) -> None:
        self.content = content

    def get(self) -> T:
        return self.content

# 具体化类型
num_box: Box[int] = Box(42)
str_box: Box[str] = Box("hi")
```

#### 🧒 小朋友视角：多功能收纳盒

Generic 泛型类就像一个多功能收纳盒：

- **普通盒子**：只能装一种东西（比如只能装积木）
- **多功能收纳盒（Generic）**：
  - 贴上"玩具"标签 → 变成玩具盒
  - 贴上"书本"标签 → 变成书箱
  - 贴上"零食"标签 → 变成零食盒

**生活例子：**
```
乐高盒子有不同系列：
- Box[积木] = 积木盒（只能放积木）
- Box[玩偶] = 玩偶盒（只能放玩偶）
- Box[汽车] = 汽车盒（只能放小汽车）

同样的盒子设计，贴不同标签就装不同东西！
```

---

### 类比3：Protocol 协议

#### 🎨 前端视角：TypeScript 接口（结构化类型）

```typescript
// TypeScript: 结构化类型（鸭子类型）
interface Printable {
  print(): string;
}

// 不需要显式 implements，只要有 print 方法就行
class Document {
  print(): string {
    return "Document content";
  }
}

function printIt(item: Printable): string {
  return item.print();
}

printIt(new Document());  // ✅ Document 有 print 方法
```

```python
# Python: Protocol 实现相同效果
from typing import Protocol

class Printable(Protocol):
    def print(self) -> str:
        ...

class Document:  # 不需要继承 Printable
    def print(self) -> str:
        return "Document content"

def print_it(item: Printable) -> str:
    return item.print()

print_it(Document())  # ✅
```

#### 🧒 小朋友视角：鸭子测试

Protocol 就像"鸭子测试"：

- **如果它走路像鸭子、叫声像鸭子，那它就是鸭子！**
- 不管它叫什么名字，只要它会"嘎嘎叫"，就可以参加"鸭子合唱团"

**生活例子：**
```
体育课选足球队员：
- 不管你是哪个班的
- 不管你叫什么名字
- 只要你会踢球，就能加入！

Protocol 就是这样：不管类叫什么，只要有需要的方法就行！
```

---

### 类比4：Optional 可选类型

#### 🎨 前端视角：TypeScript 可选参数

```typescript
// TypeScript
interface User {
  name: string;
  email?: string;  // 可选，可能是 undefined
}

function greet(name: string | null): string {
  return name ? `Hello, ${name}` : "Hello, stranger";
}
```

```python
# Python: Optional
from typing import Optional

class User:
    name: str
    email: Optional[str] = None  # 可能是 str 或 None

def greet(name: Optional[str]) -> str:
    return f"Hello, {name}" if name else "Hello, stranger"
```

#### 🧒 小朋友视角：可能有可能没有

Optional 就像"也许有礼物"：

- **必须有**：生日一定要有蛋糕
- **可选的（Optional）**：礼物可能有，也可能没有

**生活例子：**
```
填写表格：
- 姓名：必填 ✏️
- 电话：必填 ✏️
- 昵称：选填（Optional）
- 爱好：选填（Optional）

选填的格子可以空着，必填的不行！
```

---

### 类比总结表

| Python 类型 | TypeScript 类比 | 小朋友类比 |
|------------|----------------|-----------|
| `TypeVar('T')` | `<T>` 泛型参数 | 万能模具 |
| `Generic[T]` | `class Box<T>` 泛型类 | 多功能收纳盒 |
| `Protocol` | interface（结构化类型）| 鸭子测试 |
| `Optional[str]` | `string \| undefined` | 可能有可能没有 |
| `Union[str, int]` | `string \| number` | 二选一 |
| `List[str]` | `string[]` | 只装字符串的篮子 |
| `Dict[str, int]` | `Record<string, number>` | 姓名-年龄对照表 |
| `Callable[[int], str]` | `(n: number) => string` | 加工机器 |
| `Literal["a", "b"]` | `"a" \| "b"` | 只能选这几个 |
| `TypedDict` | TypeScript interface | 规定好格式的表格 |

---

## 6. 【反直觉点】

### 误区1：类型提示会在运行时检查类型 ❌

**为什么错？**
- Python 的类型提示**只是注解**，运行时完全忽略
- 类型检查需要额外工具（mypy、pyright）
- 运行时检查需要 Pydantic 等库

**为什么人们容易这样错？**
因为在 Java、TypeScript 等语言中，类型检查是强制的。Python 看起来语法类似，容易误以为也有运行时检查。

**正确理解：**

```python
def greet(name: str) -> str:
    return f"Hello, {name}"

# Python 运行时完全不检查类型！
greet(123)    # ✅ 正常运行，输出 "Hello, 123"
greet(None)   # ✅ 正常运行，输出 "Hello, None"
greet([1,2])  # ✅ 正常运行，输出 "Hello, [1, 2]"

# 要运行时检查，需要 Pydantic
from pydantic import validate_call

@validate_call
def greet_strict(name: str) -> str:
    return f"Hello, {name}"

greet_strict(123)  # ❌ ValidationError: Input should be a valid string
```

---

### 误区2：List 和 list 完全一样 ❌

**为什么错？**
- `typing.List` 是泛型容器，可以指定元素类型：`List[str]`
- `list` 在 Python 3.9 之前不能直接用作泛型：`list[str]` 会报错
- Python 3.9+ 才统一了语法

**为什么人们容易这样错？**
因为在运行时 `List` 和 `list` 确实行为一样，只是在类型注解时有区别。

**正确理解：**

```python
# Python 3.8 及之前：必须用 typing 模块
from typing import List, Dict, Optional

names: List[str] = ["Alice", "Bob"]
scores: Dict[str, int] = {"Alice": 95}

# Python 3.9+：可以直接用内置类型
names: list[str] = ["Alice", "Bob"]
scores: dict[str, int] = {"Alice": 95}

# Python 3.10+：Union 可以用 |
value: str | int = "hello"
maybe: str | None = None  # 等同于 Optional[str]
```

**建议：** 新项目用 Python 3.10+，使用简化语法

---

### 误区3：TypeVar 是定义新类型 ❌

**为什么错？**
- TypeVar 是**类型变量**，不是新类型
- 它是一个"占位符"，在具体使用时被替换为实际类型
- 类似于数学中的变量 x，不是具体数值

**为什么人们容易这样错？**
因为 TypeVar 看起来像是在"创建"什么东西，容易误以为是定义新类型。

**正确理解：**

```python
from typing import TypeVar, List

# T 不是一个新类型，而是一个"类型变量"
T = TypeVar('T')

def first(items: List[T]) -> T:
    return items[0]

# 调用时，T 被具体类型"替换"
first([1, 2, 3])      # T = int，返回 int
first(["a", "b"])     # T = str，返回 str
first([1.0, 2.0])     # T = float，返回 float

# T 本身不是类型，不能直接用
x: T = 1  # ❌ 没有意义，T 不是具体类型
```

**类比：**
- `T = TypeVar('T')` 就像数学中的 `设 x 为任意数`
- 不是说 x 等于某个数，而是 x 可以代表任何数

---

## 7. 【实战代码】

```python
"""
示例：使用类型提示构建类型安全的 LangChain 风格组件
演示 TypeVar、Generic、Protocol 在实际项目中的应用
"""

from typing import TypeVar, Generic, Protocol, Optional, List, Callable, Union
from abc import ABC, abstractmethod
from dataclasses import dataclass

# ===== 1. 基础类型注解 =====
print("=== 1. 基础类型注解 ===")

@dataclass
class Message:
    """消息类 - 类似 LangChain 的 BaseMessage"""
    role: str
    content: str
    name: Optional[str] = None

def format_messages(messages: List[Message]) -> str:
    """格式化消息列表"""
    return "\n".join(f"[{m.role}]: {m.content}" for m in messages)

messages = [
    Message(role="system", content="You are helpful"),
    Message(role="user", content="Hello!")
]
print(format_messages(messages))

# ===== 2. TypeVar 泛型函数 =====
print("\n=== 2. TypeVar 泛型函数 ===")

T = TypeVar('T')

def first_or_default(items: List[T], default: T) -> T:
    """返回第一个元素，或默认值"""
    return items[0] if items else default

# 类型自动推导
num = first_or_default([1, 2, 3], 0)        # int
text = first_or_default(["a", "b"], "")     # str
msg = first_or_default([], Message("default", "empty"))  # Message

print(f"First number: {num}")
print(f"First text: {text}")
print(f"Default message: {msg}")

# ===== 3. Generic 泛型类 - 模拟 Runnable =====
print("\n=== 3. Generic 泛型类 - 模拟 Runnable ===")

Input = TypeVar('Input')
Output = TypeVar('Output')

class Runnable(Generic[Input, Output], ABC):
    """可运行组件的抽象基类 - 简化版 LangChain Runnable"""

    @abstractmethod
    def invoke(self, input: Input) -> Output:
        """同步调用"""
        pass

    def __or__(self, other: 'Runnable[Output, T]') -> 'RunnableSequence[Input, T]':
        """链式组合：self | other"""
        return RunnableSequence(self, other)

T = TypeVar('T')

class RunnableSequence(Runnable[Input, T]):
    """顺序执行的 Runnable 链"""

    def __init__(
        self,
        first: Runnable[Input, Output],
        second: Runnable[Output, T]
    ) -> None:
        self.first = first
        self.second = second

    def invoke(self, input: Input) -> T:
        intermediate = self.first.invoke(input)
        return self.second.invoke(intermediate)

class RunnableLambda(Runnable[Input, Output]):
    """将普通函数包装成 Runnable"""

    def __init__(self, func: Callable[[Input], Output]) -> None:
        self.func = func

    def invoke(self, input: Input) -> Output:
        return self.func(input)

# 使用泛型组件
add_one: Runnable[int, int] = RunnableLambda(lambda x: x + 1)
to_string: Runnable[int, str] = RunnableLambda(lambda x: f"Result: {x}")

# 链式组合
chain: Runnable[int, str] = add_one | to_string

result = chain.invoke(5)
print(f"Chain result: {result}")  # "Result: 6"

# ===== 4. Protocol 协议 - 结构化子类型 =====
print("\n=== 4. Protocol 协议 ===")

class Invocable(Protocol[Input, Output]):
    """可调用协议 - 任何有 invoke 方法的对象"""
    def invoke(self, input: Input) -> Output:
        ...

def run_invocable(
    invocable: Invocable[str, str],
    input: str
) -> str:
    """运行任何可调用的对象"""
    return invocable.invoke(input)

# 任何有 invoke 方法的类都可以
class SimpleProcessor:
    def invoke(self, input: str) -> str:
        return input.upper()

processor = SimpleProcessor()
print(run_invocable(processor, "hello"))  # "HELLO"

# ===== 5. 实际应用：类型安全的消息处理 =====
print("\n=== 5. 类型安全的消息处理 ===")

class ChatModel(Runnable[List[Message], Message]):
    """聊天模型 - 输入消息列表，输出单条消息"""

    def __init__(self, model_name: str = "mock-model") -> None:
        self.model_name = model_name

    def invoke(self, input: List[Message]) -> Message:
        # 模拟 LLM 响应
        user_msg = next((m for m in reversed(input) if m.role == "user"), None)
        content = f"Echo: {user_msg.content}" if user_msg else "No message"
        return Message(role="assistant", content=content)

class OutputParser(Runnable[Message, str]):
    """输出解析器 - 提取消息内容"""

    def invoke(self, input: Message) -> str:
        return input.content

# 构建类型安全的链
chat_model = ChatModel()
parser = OutputParser()

# 类型检查会验证 ChatModel 的输出类型与 OutputParser 的输入类型匹配
full_chain: Runnable[List[Message], str] = chat_model | parser

# 运行链
messages = [
    Message(role="system", content="You are helpful"),
    Message(role="user", content="Hi there!")
]
response = full_chain.invoke(messages)
print(f"Response: {response}")

# ===== 6. 高级类型：Union 和 Literal =====
print("\n=== 6. 高级类型 ===")

from typing import Literal, TypedDict

class ModelConfig(TypedDict, total=False):
    """模型配置 - 类型化字典"""
    model: str
    temperature: float
    max_tokens: int

def create_model(
    config: ModelConfig,
    mode: Literal["chat", "completion"] = "chat"
) -> str:
    model = config.get("model", "gpt-4")
    return f"Created {mode} model: {model}"

config: ModelConfig = {"model": "gpt-4-turbo", "temperature": 0.7}
print(create_model(config, "chat"))

# ===== 7. 类型守卫函数 =====
print("\n=== 7. 类型守卫 ===")

from typing import TypeGuard

def is_string_list(items: List[Union[str, int]]) -> TypeGuard[List[str]]:
    """类型守卫：检查是否全是字符串"""
    return all(isinstance(item, str) for item in items)

def process_items(items: List[Union[str, int]]) -> str:
    if is_string_list(items):
        # 这里 items 被缩窄为 List[str]
        return ", ".join(items)  # 类型检查器知道这是安全的
    return ", ".join(str(i) for i in items)

print(process_items(["a", "b", "c"]))  # "a, b, c"
print(process_items([1, 2, 3]))        # "1, 2, 3"
```

**运行输出示例：**
```
=== 1. 基础类型注解 ===
[system]: You are helpful
[user]: Hello!

=== 2. TypeVar 泛型函数 ===
First number: 1
First text: a
Default message: Message(role='default', content='empty', name=None)

=== 3. Generic 泛型类 - 模拟 Runnable ===
Chain result: Result: 6

=== 4. Protocol 协议 ===
HELLO

=== 5. 类型安全的消息处理 ===
Response: Echo: Hi there!

=== 6. 高级类型 ===
Created chat model: gpt-4-turbo

=== 7. 类型守卫 ===
a, b, c
1, 2, 3
```

---

## 8. 【面试必问】

### 问题："Python 的类型提示有什么用？和 TypeScript 有什么区别？"

**普通回答（❌ 不出彩）：**
"类型提示可以让代码更清晰，IDE 可以提供补全。和 TypeScript 差不多。"

**出彩回答（✅ 推荐）：**

> **Python 类型提示有三个核心价值：**
>
> 1. **代码即文档**：类型注解让函数签名自解释，不用看实现就知道接受什么、返回什么
>
> 2. **IDE 智能支持**：PyCharm、VS Code 可以提供准确的自动补全和重构支持
>
> 3. **静态检查**：配合 mypy/pyright 可以在运行前发现类型错误
>
> **和 TypeScript 的核心区别**：
>
> - **TypeScript**：类型检查是**编译时强制**的，不通过检查代码无法运行
> - **Python**：类型提示是**可选的注解**，运行时完全忽略，需要额外工具检查
>
> 这意味着 Python 更灵活但也更危险，很多项目选择用 Pydantic 在运行时强制验证类型。
>
> **在 LangChain 中的应用**：LangChain 大量使用泛型（`Runnable[Input, Output]`）来定义组件的类型契约，这让 Chain 组合时可以静态验证类型兼容性。

**为什么这个回答出彩？**
1. ✅ 分层回答，有结构
2. ✅ 明确了 Python 和 TypeScript 的本质区别
3. ✅ 提到了实际解决方案（Pydantic）
4. ✅ 联系了 LangChain 实际应用

---

### 问题："TypeVar 和 Generic 有什么区别？什么时候用哪个？"

**普通回答（❌ 不出彩）：**
"TypeVar 定义类型变量，Generic 定义泛型类。"

**出彩回答（✅ 推荐）：**

> **TypeVar 和 Generic 是配合使用的：**
>
> - **TypeVar**：定义一个"类型占位符"，类似数学中的变量 x
> - **Generic**：让类可以使用类型占位符作为参数
>
> **使用场景：**
>
> 1. **只需要泛型函数**时，只用 TypeVar：
> ```python
> T = TypeVar('T')
> def first(items: List[T]) -> T:
>     return items[0]
> ```
>
> 2. **需要泛型类**时，TypeVar + Generic 配合：
> ```python
> T = TypeVar('T')
> class Box(Generic[T]):
>     def __init__(self, value: T) -> None:
>         self.value = value
> ```
>
> **LangChain 的例子**：
> ```python
> Input = TypeVar("Input")
> Output = TypeVar("Output")
>
> class Runnable(Generic[Input, Output]):
>     def invoke(self, input: Input) -> Output: ...
> ```
>
> 这里 Input 和 Output 是类型变量，Runnable 是泛型类。具体的 Runnable 实现（如 `ChatModel`）会指定具体类型。

---

## 9. 【化骨绵掌】

### 卡片1：类型提示是什么？ 🎯

**一句话：** 类型提示是给变量和函数添加类型信息的注解，让代码意图更清晰。

**举例：**
```python
def greet(name: str) -> str:
    return f"Hello, {name}"
```

**应用：** LangChain 源码中所有函数都有类型注解，方便阅读和 IDE 补全。

---

### 卡片2：基础类型注解语法 📐

**一句话：** 用 `:` 标注变量类型，用 `->` 标注返回类型。

**举例：**
```python
name: str = "Alice"           # 变量
count: int = 10               # 变量
def add(a: int, b: int) -> int:  # 函数
    return a + b
```

**应用：** 阅读 LangChain 源码的第一步就是理解这些基础注解。

---

### 卡片3：复合类型 List/Dict/Optional 📦

**一句话：** 用 `List[T]`、`Dict[K,V]`、`Optional[T]` 表示容器和可选类型。

**举例：**
```python
from typing import List, Dict, Optional

names: List[str] = ["Alice", "Bob"]
scores: Dict[str, int] = {"Alice": 95}
config: Optional[dict] = None  # 可以是 dict 或 None
```

**应用：** LangChain 消息列表就是 `List[BaseMessage]`。

---

### 卡片4：Union 联合类型 🔀

**一句话：** `Union[A, B]` 表示可以是 A 类型或 B 类型。

**举例：**
```python
from typing import Union

# 可以是字符串或整数
user_id: Union[str, int] = "user_123"
user_id = 123  # 也可以

# Python 3.10+ 简化语法
user_id: str | int = "user_123"
```

**应用：** LangChain 消息内容 `content: Union[str, List]`。

---

### 卡片5：TypeVar 类型变量 🔧

**一句话：** TypeVar 定义一个类型占位符，让函数能处理多种类型。

**举例：**
```python
from typing import TypeVar, List

T = TypeVar('T')

def first(items: List[T]) -> T:
    return items[0]

# T 自动推导
first([1, 2, 3])      # T = int
first(["a", "b"])     # T = str
```

**应用：** LangChain 的 `Input = TypeVar("Input")`。

---

### 卡片6：Generic 泛型类 🏗️

**一句话：** `Generic[T]` 让类可以参数化类型，创建可复用的类型安全容器。

**举例：**
```python
from typing import TypeVar, Generic

T = TypeVar('T')

class Box(Generic[T]):
    def __init__(self, value: T) -> None:
        self.value = value

int_box: Box[int] = Box(42)
str_box: Box[str] = Box("hello")
```

**应用：** LangChain 的 `Runnable(Generic[Input, Output])`。

---

### 卡片7：Protocol 协议 📋

**一句话：** Protocol 定义结构化子类型，不需要显式继承，只要有方法就行。

**举例：**
```python
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> str: ...

class Circle:  # 不需要继承
    def draw(self) -> str:
        return "○"

def render(shape: Drawable) -> str:
    return shape.draw()
```

**应用：** Runnable 本质上就是一个 Protocol。

---

### 卡片8：Callable 可调用类型 📞

**一句话：** `Callable[[参数类型], 返回类型]` 表示函数类型。

**举例：**
```python
from typing import Callable

# 接受 int，返回 str 的函数
Processor = Callable[[int], str]

def apply(func: Processor, value: int) -> str:
    return func(value)
```

**应用：** LangChain 的 RunnableLambda 接受 `Callable` 参数。

---

### 卡片9：Literal 和 TypedDict 🎯

**一句话：** Literal 限制值只能是特定字面量，TypedDict 定义字典的键值类型。

**举例：**
```python
from typing import Literal, TypedDict

Mode = Literal["read", "write"]  # 只能是这两个值

class Config(TypedDict):
    model: str
    temperature: float
```

**应用：** LangChain 的 `RunnableConfig` 就是 TypedDict。

---

### 卡片10：在 LangChain 源码中的应用 ⭐

**一句话：** LangChain 用泛型定义 Runnable 协议，实现类型安全的组件组合。

**举例：**
```python
# langchain_core/runnables/base.py
Input = TypeVar("Input")
Output = TypeVar("Output")

class Runnable(Generic[Input, Output], ABC):
    def invoke(self, input: Input) -> Output: ...

# 具体实现
class ChatModel(Runnable[List[Message], AIMessage]): ...
class StrParser(Runnable[AIMessage, str]): ...

# 链式组合：类型自动推导
chain: Runnable[List[Message], str] = chat_model | parser
```

**应用：** 理解这个模式就能读懂 LangChain 的核心架构。

---

## 10. 【一句话总结】

**类型提示是 Python 的静态类型注解系统，通过 TypeVar 和 Generic 实现泛型编程，虽然运行时不检查但能让代码更清晰、IDE 更智能，是 LangChain Runnable 协议的类型安全基石。**

---

## 📚 学习检查清单

- [ ] 理解基础类型注解语法（`:` 和 `->`）
- [ ] 会使用 List、Dict、Optional、Union
- [ ] 理解 TypeVar 是类型变量，不是新类型
- [ ] 会用 Generic 定义泛型类
- [ ] 理解 Protocol 的结构化子类型概念
- [ ] 能阅读 LangChain 源码中的 `Runnable[Input, Output]`
- [ ] 知道类型提示不会在运行时检查

## 🔗 下一步学习

- **Pydantic 数据验证**：运行时类型验证
- **异步编程 async/await**：LangChain 的异步接口
- **Runnable 协议**：LangChain 核心抽象

---

**版本：** v1.0
**最后更新：** 2025-01-14
